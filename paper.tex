% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}
\usepackage{booktabs}   %% For formal tables:
%% http://ctan.org/pkg/booktabs
%\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
%% http://ctan.org/pkg/subcaption
\usepackage{xcolor} %% For \color
\usepackage{todonotes} %% For \todo
\usepackage{mathtools} %% For \xRightarrow[sub]{sup}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd} %% For \llbracket etc.
\usepackage{semantic}
\usepackage[scaled]{beramono}
\usepackage[T1]{fontenc}
%\usepackage[numbers]{natbib} %% For more citation commames (\cite etc.)
\usepackage{natbib} %% For more citation commames (\cite etc.)
\usepackage{listings} %% For typesetting code
\newcommand{\lstsetgrift}{
	\lstset{%
		language=Lisp,%
		basicstyle=\ttfamily\small,%
		keywordstyle=\ttfamily\bfseries\small,%
		columns=flexible,%
		aboveskip=\smallskipamount,%
		belowskip=\smallskipamount,%
		frame=single,%
		xleftmargin=2pt,%
		escapeinside={/+}{+/},%
		mathescape=true,%
		keywords=[1]{define,if,:,Int,Bool,-,=,open},
		literate=%
		{->}{{$\rightarrow$}}2%
		{=>}{{$\Rightarrow$}}2%
		{lambda}{{$\lambda$}}1%
		{→}{{$\rightarrow$ }}2%
		{Γ}{{$\Gamma$ }}1%
		{⊢}{{$\vdash$ }}1%
	}%
}%%
\lstsetgrift

% random stuff
\newcommand{\infr}[2]{\inference{#1}{#2}}
\newcommand{\highlight}[1]{{\color{red} #1}}
\newcommand{\sidecond}[1]{\text{if}\;#1}
\newcommand{\urlFrameworkAndIllustration}{
	\url{https://github.com/LuKC1024/esop-2020}
}

% abbreviations in figures
\newcommand{\figreduceto}[3]{#1 & \longmapsto & #2 & #3 \\}
\newcommand{\figreducetoH}[3]{\highlight{#1} & \highlight{\longmapsto} & 
\highlight{#2} & \highlight{#3} \\}
\newcommand{\figequalto}[3]{#1 & = & #2 & #3 \\}
\newcommand{\figequaltoH}[3]{\highlight{#1} & \highlight{=} & \highlight{#2} & 
\highlight{#3} \\}
\newcommand{\stxinrule}[3]{\text{#2} & #1 & \in & #3\\}
\newcommand{\stxrule}[3]{\text{#2} & #1 & \Coloneqq & #3\\}
\newcommand{\stxrulecont}[1]{& & | & #1 \\}

% ref figures, sections, etc.
\newcommand{\figref}[1]{Fig.~\ref{#1}}
\newcommand{\secref}[1]{Section~\ref{#1}}
\newcommand{\chapref}[1]{Section~\ref{#1}}

% names
\newcommand{\LUD}{\ensuremath{\text{Lazy\;UD}}}
\newcommand{\LD}{\ensuremath{\text{Lazy\;D}}}
\newcommand{\CastADT}{\ensuremath{\text{Cast ADT}}}
\newcommand{\CMachine}[1]{\ensuremath{\mathcal{C}(#1)}}
\newcommand{\LDMachine}{\CMachine{\BLD}}
\newcommand{\LUDMachine}{\CMachine{\BLUD}}
\newcommand{\CBMachine}[0]{\CMachine{B}}
\newcommand{\SMachine}[1]{\ensuremath{\mathcal{S}(#1)}}
\newcommand{\effCEK}[1]{\ensuremath{\mathcal{S}(#1)}}

% error monad
\newcommand{\just}[1]{\ensuremath{#1}}
\newcommand{\error}[1]{\ensuremath{\Uparrow#1}}

% types
\newcommand{\Tdyn}[0]{\ensuremath{\star}}

%% pre-types
\newcommand{\Pbool}[0]{\ensuremath{\mathtt{Bool}}}
\newcommand{\Pfunc}[2]{\ensuremath{#1 \shortrightarrow #2}}
\newcommand{\Pprod}[2]{\ensuremath{#1 \times #2}}

% ground types
\newcommand{\Gbool}[0]{\Pbool}
\newcommand{\Gfunc}[0]{\Pfunc{\Tdyn}{\Tdyn}}
\newcommand{\Gprod}[0]{\Pprod{\Tdyn}{\Tdyn}}

%% expressions
\newcommand{\econ}[1]{#1}
\newcommand{\evar}[1]{#1}
\newcommand{\elam}[3]{\lambda#1:#2.\;#3}
\newcommand{\eapp}[2]{#1\;#2}
\newcommand{\etrue}[0]{\mathtt{true}}
\newcommand{\efalse}[0]{\mathtt{false}}
\newcommand{\eif}[3]{\mathtt{if}\;#1\;#2\;#3}
\newcommand{\econs}[2]{\mathtt{cons} \; #1 \; #2}
\newcommand{\efst}[1]{\mathtt{fst} \; #1}
\newcommand{\esnd}[1]{\mathtt{snd} \; #1}
%\newcommand{\ecast}[2]{#1 \langle #2 \rangle}
\newcommand{\ecast}[2]{\ensuremath{#1 : #2}}

% casts
\newcommand{\ccast}[3]{#1 \xRightarrow[]{\enskip #2 \enskip} #3}
% \Rightarrow^{#2}

% values
\newcommand{\vdyn}[2]{\mathtt{Dyn}_{#1}(#2)}
\newcommand{\vtrue}[0]{\mathtt{true}}
\newcommand{\vfalse}[0]{\mathtt{false}}
\newcommand{\vfunc}[4]{\langle\elam{#1}{#2}{#3},#4\rangle}
\newcommand{\vfuncc}[6]{\ecast{#1}{\ccast{\Pfunc{#2}{#3}}{#4}{\Pfunc{#5}{#6}}}}
\newcommand{\vcons}[2]{\econs{#1}{#2}}
\newcommand{\vconsc}[6]{\ecast{#1}{\ccast{\Pprod{#2}{#3}}{#4}{\Pprod{#5}{#6}}}}

% observables
\newcommand{\odyn}{\ensuremath{\mathtt{dynamic}}}
\newcommand{\otrue}[0]{\mathtt{true}}
\newcommand{\ofalse}[0]{\mathtt{false}}
\newcommand{\ofunc}[0]{\mathtt{function}}
\newcommand{\ocons}[0]{\mathtt{cons}}
\newcommand{\oerror}[1]{\error{#1}}

% blame strategies
\newcommand{\BLD}[0]{\ensuremath{\mathtt{LD}}}
\newcommand{\BLUD}[0]{\ensuremath{\mathtt{LUD}}}

% cast _r_esults
\newcommand{\rsucc}[1]{\mathtt{succ}\;#1}
\newcommand{\rfail}[1]{\mathtt{fail}\;#1}

% machine _s_tates
\newcommand{\sexpr}[3]{\ensuremath{\langle#1,#2,#3\rangle}}
\newcommand{\scont}[2]{\ensuremath{\langle#1,#2\rangle}}
\newcommand{\shalt}[1]{\ensuremath{\mathop{\Downarrow} #1}}

% continuations
\newcommand{\Knil}[0]{\Box}
\newcommand{\Kcons}[2]{[#1]#2}

% frames
\newcommand{\closure}[2]{\langle#1,#2\rangle}
\newcommand{\FappXO}[2]{\eapp{\square}{\closure{#1}{#2}}}
\newcommand{\FappOX}[1]{\eapp{#1}{\square}}
\newcommand{\Fif}[3]{\eif{\square}{\closure{#1}{#3}}{\closure{#2}{#3}}}
\newcommand{\FconsXO}[2]{\econs{\square}{\closure{#1}{#2}}}
\newcommand{\FconsOX}[1]{\econs{#1}{\square}}
\newcommand{\Ffst}[0]{\efst{\square}}
\newcommand{\Fsnd}[0]{\esnd{\square}}
\newcommand{\Fcast}[1]{\ecast{\square}{#1}}

% threesomes
\newcommand{\tscc}[3]{\ccast{#1}{#2}{#3}}
%\newcommand{\tsTp}[2]{({#1};{#2})}
\newcommand{\tsTp}[2]{{#2}^{#1}}
\newcommand{\tsTdyn}[0]{\Tdyn}
\newcommand{\tsPbool}[0]{\Pbool}
\newcommand{\tsPfunc}[2]{\Pfunc{#1}{#2}}
\newcommand{\tsPprod}[2]{\Pprod{#1}{#2}}
\newcommand{\tsPfail}[2]{\bot^{#1#2}}
\newcommand{\tsle}[0]{\epsilon}
%\newcommand{\tsll}[1]{\cnfproj{}{#1}}
\newcommand{\tsll}[1]{#1}

% coercions in normal form
\newcommand{\cnfproj}[2]{#1?^{#2}}
\newcommand{\cnfinj}[1]{#1!}
\newcommand{\cnfseq}[2]{#1;#2}
\newcommand{\cnffail}[1]{\bot^{#1}}
\newcommand{\cnffunc}[2]{\Pfunc{#1}{#2}}
\newcommand{\cnfprod}[2]{\Pprod{#1}{#2}}
\newcommand{\cnfid}[1]{\ensuremath{\mathtt{id}_{#1}}}

% hypercoercions
\newcommand{\hcci}[0]{\cnfid{\Tdyn}}
\newcommand{\hccc}[3]{\ensuremath{(#1;#2;#3)}}
\newcommand{\hche}[0]{\ensuremath{\epsilon}}
\newcommand{\hchp}[2]{\ensuremath{#1?^{#2}}}
\newcommand{\hcmbool}[0]{\Pbool}
\newcommand{\hcmfunc}[2]{\Pfunc{#1}{#2}}
\newcommand{\hcmprod}[2]{\Pprod{#1}{#2}}
\newcommand{\hcmfail}[1]{\ensuremath{\bot^l}}
\newcommand{\hcte}[0]{\ensuremath{\epsilon}}
\newcommand{\hcti}[1]{\ensuremath{#1!}}

% gaps
\newcommand{\gnone}{\ensuremath{\epsilon}}
\newcommand{\gsome}[3]{\ccast{#1}{#2}{#3}}

% operators
\newcommand{\mbind}[0]{\ensuremath{\;\gg=\;}}
\newcommand{\mcomp}[0]{\ensuremath{\;>=>\;}}

% functions
\newcommand{\meet}[2]{\ensuremath{#1 \sqcap #2}}
\newcommand{\denote}[1]{\ensuremath{\llbracket #1 \rrbracket}}
\newcommand{\proxy}[2]{\ensuremath{\mathrm{proxy}(#1,#2)}}
\newcommand{\applyCast}[2]{\ensuremath{\mathrm{applyCast}(#1,#2)}}
\newcommand{\project}[4]{\ensuremath{\mathrm{project}(#1,#2,#3,#4)}}
\newcommand{\composegap}[3]{\ensuremath{#1 \fatsemi #2 \fatsemi #3}}
\newcommand{\mkhead}[2]{\ensuremath{\mathrm{mkProj}(#1,#2)}}
\newcommand{\mktail}[2]{\ensuremath{\mathrm{mkInj}(#1,#2)}}
\newcommand{\mkgap}[3]{\ensuremath{\mathrm{mkGap}(#1,#2,#3)}}
\newcommand{\compose}[2]{\ensuremath{#1 \fatsemi #2}}
\newcommand{\translate}[1]{\ensuremath{\lceil#1\rceil}}
\newcommand{\castToDyn}[2]{\ensuremath{\mathrm{castToDyn}(#1,#2)}}
\newcommand{\castFromDyn}[2]{\ensuremath{\mathrm{castFromDyn}(#1,#2)}}
\newcommand{\dom}[1]{\ensuremath{\mathrm{dom}(#1)}}
\newcommand{\cod}[1]{\ensuremath{\mathrm{cod}(#1)}}
\newcommand{\fst}[1]{\ensuremath{\mathrm{fst}(#1)}}
\newcommand{\snd}[1]{\ensuremath{\mathrm{snd}(#1)}}
\newcommand{\id}[1]{\ensuremath{\mathrm{id}(#1)}}
\newcommand{\idm}[1]{\ensuremath{\mathrm{id}_m(#1)}}
\newcommand{\idc}[1]{\ensuremath{\mathrm{id}_c(#1)}}
\newcommand{\mkContName}[0]{\ensuremath{\mathrm{mkK}}}
\newcommand{\mkCont}[1]{\ensuremath{\mkContName(#1)}}
\newcommand{\extContName}[0]{\ensuremath{\mathrm{extK}}}
\newcommand{\extCont}[2]{\ensuremath{\extContName(#1,#2)}}
% \newcommand{\applyCont}[2]{\ensuremath{\langle\langle#1,#2\rangle\rangle}}
\newcommand{\applyContName}[0]{\ensuremath{\mathrm{applyK}}}
\newcommand{\applyCont}[2]{\ensuremath{\applyContName(#1,#2)}}

% other relations
\newcommand{\tailable}[2]{\ensuremath{\casttyping{!}{#1}{#2}}}
\newcommand{\consistent}[2]{\ensuremath{#1\sim#2}}
\newcommand{\shallowlyconsistent}[2]{\ensuremath{#1\smile#2}}
\newcommand{\notshallowlyconsistent}[2]{\ensuremath{#1\not\smile#2}}
\newcommand{\expressiontyping}[3]{\ensuremath{#1 \vdash #2 : #3}}
\newcommand{\matching}[2]{\ensuremath{#1 \triangleright #2}}
\newcommand{\valuetyping}[2]{\ensuremath{\vdash #1 : #2}}
\newcommand{\envtyping}[2]{\ensuremath{#1 \vdash #2}}
\newcommand{\casttyping}[3]{\ensuremath{\vdash #1 : #2 \Longrightarrow #3}}
\newcommand{\transitivelyreducetoM}[3]{\ensuremath{#2 \longmapsto_{#1}^{*} #3}}
\newcommand{\transitivelyreduceto}[2]{\ensuremath{#1 \longmapsto^{*} #2}}
\newcommand{\transitivelyreducetoD}[2]{
	\ensuremath{#1 \longmapsto_{\LDMachine}^{*} #2}}
\newcommand{\transitivelyreducetoUD}[2]{
	\ensuremath{#1 \longmapsto_{\LUDMachine}^{*} #2}}
\newcommand{\reduceto}[2]{\ensuremath{#1 \longmapsto #2}}
\newcommand{\reducetoR}[3]{\ensuremath{#2 \longmapsto_{\CMachine{#1}} #3}}
\newcommand{\reducetoD}[2]{\reducetoR{\BLD}{#1}{#2}}
\newcommand{\reducetoUD}[2]{\reducetoR{\BLUD}{#1}{#2}}
\newcommand{\reducetoS}[3]{\ensuremath{#2 \longmapsto_{\SMachine{#1}} #3}}
\newcommand{\evalto}[2]{\ensuremath{\mathit{eval}(#1)=#2}}
\newcommand{\withmachineevalto}[3]{\ensuremath{\mathit{eval}_{#1}(#2)=#3}}
\newcommand{\evaltoR}[3]{\ensuremath{\mathit{eval}_{\CMachine{#1}}(#2)=#3}}
\newcommand{\evaltoD}[2]{\evaltoR{\BLD}{#1}{#2}}
\newcommand{\evaltoUD}[2]{\evaltoR{\BLUD}{#1}{#2}}
\newcommand{\evaltoS}[3]{\ensuremath{\mathit{eval}_{\SMachine{#1}}(#2)=#3}}
\newcommand{\compatibletailhead}[2]{\ensuremath{#1\;\mathit{R}\;#2}}
\newcommand{\goodgap}[1]{\ensuremath{\mathit{good}(#1)}}
\newcommand{\compileto}[4]{\expressiontyping{#1}{#2\rightsquigarrow#3}{#4}}
\newcommand{\machineequiv}[2]{
	\ensuremath{
		\withmachineevalto{#1}{e}{o}	
		\text{ if and only if }
		\withmachineevalto{#2}{e}{o}
		\text{ for all }
		\expressiontyping{\emptyset}{e}{T}
		\text{ and }
		\valuetyping{o}{T}
	}}
\newcommand{\bisimE}[3]{\ensuremath{#1 \vdash #2 \approx #3}}
\newcommand{\bisimv}[3]{\valuetyping{#1 \approx #2}{#3}}
\newcommand{\bisimr}[3]{\valuetyping{#1 \approx #2}{#3}}
\newcommand{\bisimF}[4]{\casttyping{#1 \approx #2}{#3}{#4}}
\newcommand{\bisimc}[4]{\casttyping{#1 \approx #2}{#3}{#4}}
\newcommand{\bisimK}[4]{\casttyping{#1 \approx #2}{#3}{#4}}
\newcommand{\bisims}[3]{\valuetyping{\ensuremath{#1 \approx #2}}{#3}}

\begin{document}
%
\title{A Framework for Equivalence of Cast Calculi and a new Cast Representation}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Kuang-Chen Lu\inst{1} \and
Jeremy G. Siek\inst{2} \and
Andre Kuhlenschmidt\inst{2}
}
%
\authorrunning{F. Author et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Brown University, Providence RI 02912, USA \and
Indiana University, Bloomington IN 47405, USA}
% \institute{Princeton University, Princeton NJ 08544, USA \and
% Springer Heidelberg, Tiergartenstr. 17, 69121 Heidelberg, Germany
% \email{lncs@springer.com}\\
% \url{http://www.springer.com/gp/computer-science/lncs} \and
% ABC Institute, Rupert-Karls-University Heidelberg, Heidelberg, Germany\\
% \email{\{abc,lncs\}@uni-heidelberg.de}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
Gradual typing aims at combining dynamic typing and static typing in one 
language to provide the advantages of both typing disciplines. Implementing 
gradual typing with reasonable overhead, however, is not trivial. Casts might 
accumulate in higher-order values and continuations, thus change the overall 
space complexity. Several space-efficient cast representations have been 
proposed, notably coercions in normal forms and threesomes. But they are
presented in different dynamic semantics, which make it difficult to compare
the key differences between the cast representations. We present a abstrat
data type, namely Cast ADT, that captures interface functions a cast representations
typically includes, and an abstract machine parameterized over Cast ADTs.
The Cast ADT brings another benefit: space-efficient cast representations 
shall be proved not changing the 
overall behavior of language implementations except saving space.
With our generic abstract machine, these proofs can be done by proving properties
of a specific Cast ADT, which is simpler than going through a bisimulation proof 
between a space-efficient dynamic semantics and the definitional dynamic semantics.
We have successfully applied our new approach of proving the correctness of cast 
representations to several known cast representations and believe this framework
is also applicable to other cast representations.
\todo[inline]{JS: cite which other cast representations}
We also present a new cast representation, hypercoercions, that is more friendly
to mechanized meta-theory and hypothetically consume less memory than coercions
in normal forms.

% The abstract should briefly summarize the contents of the paper in
% 15--250 words. 

\keywords{Gradual Typing \and Blame \and Coercion.}
\end{abstract}
%
%
%

\section{Introduction}
Around 2006, several groups of researchers proposed ways to integrate
dynamic typing and static typing, notably gradual typing
\citep{siek2006gradual}, hybrid typing \citep{knowles2010hybrid},
migratory typing \citep{tobin2006interlanguage}, and multi-language
interoperability \citep{Gray:2005ij,Matthews:2007zr}.

\todo[inline]{KC: Cite "Contracts for higher-order functions" for the proxy-based approach maybe?}
\todo[inline]{JS: That paper doesn't exactly fit into what you're talking about in the above
sentence. It might be appopriate to cite it elsewhere in the paper. Also,
there are earlier papers about coercive subtyping (Computing with coercions by Breazu-Tannen et al)
that use a proxy-based approach. The contracts paper may be the first to propose blame tracking.}
\todo[inline]{KC: I think readers should be able to trace back history by following the pointers in the 
intro section. I don't know whether my thought is correct. I would rather not giving misleading
pointers. I also don't know how far should a pointer chases back. Readers can be directed to recently
works which will eventually lead them back to the earliest possible paper. But wouldn't it be
great if the author of a new paper shows reader all the milestones? After all we already know 
pointer dereferencing is expensive.}
\todo[inline]{JS: Yes, citing the original paper for each idea is great.
  I'm just saying 1) cite the correct paper for each idea and 2)
  talk about the various ideas in an organized way with respect
  to your sentence and paragraph structure.}

Gradual typing \citep{siek2006gradual,siek2015refined} includes both static typing 
and dynamic typing in the same language and enables a smooth transition between them while
enforcing type soundness.
To enable a smooth transition, gradually typed languages feature a special type
typically written as \Tdyn{}, \lstinline|Dyn|, or \lstinline|Any|, which
provides a way to write imprecise type annotations. A gradual type checker allows programmers to cast 
implicitly between types that have no conflicting type information.
At runtime, casts record and check type information to enforce type soundness.
Researchers often define the semantics of gradually typed languages by
translation to an intermediate language with explicit casts, such as the blame
calculus \citep{wadler2009well} and other cast calculi \citep{siek2009exploring}.
% To allow the smooth transition, every gradually typed language
% has a special type typically written as \Tdyn\ or \lstinline|Dyn| or \lstinline|Any|,
% which enables imprecise type annotations.
% Programmers can use an expression of type \texttt{T} in any context that \texttt{T} 
% is consistent to.
% Two types are consistent if they have no conflicting type information.
% For instance, \lstinline|(->  Bool Int)| is consistent with \lstinline|(->  $\star$ Int)| but
% not consistent with \lstinline|(->  Int Int)|.
% When the type of an expression is consistent but not equal to the type of its 
% context, there would be a runtime computation (i.e. a cast) that store or check 
% type information to enforce type soundness.


Unfortunately, straightforward implementations of casts impose significant 
runtime overheads that can change the asymptotic space complexity of a program 
\citep{herman2010space}.
For instance, consider the following functions 
that check the parity of natural numbers. The terms are ordinary, while the 
type annotations are not -- the output type of \lstinline|even?| is 
imprecise.
\begin{lstlisting}
(define (even? [n : Int]) : $\star$
  (if (= n 0) #t (odd? (- n 1))))
(define (odd? [n : Int]) : Bool
  (if (= n 0) #f (even? (- n 1))))
\end{lstlisting}
These functions look tail-recursive, so it is natural to expect that
they consumes constant space. This is not the case, however, in a
straightforward implementation because there is an implicit cast
around each of the recursive calls, one from \lstinline|Bool| to
\lstinline|$\star$| and the other from \lstinline|$\star$| to
\lstinline|Bool|.  A straightforward implementation would perform this
cast after the recursive calls but \textit{before} returning from the
current function. So the calls are not in fact tail calls and the
space complexity is linear instead of constant.

Continuations are not the only place where casts can accumulate.
Consider a variant of the above program written in
continuation-passing style.  Here, both functions returns
\lstinline|Bool| so there is no implicit cast in tail position.
However, the argument \lstinline|k| is wrapped in a cast in each
recursive call because the type of \lstinline|k| is less precise in
\lstinline|even?| than it is in \lstinline|odd?|.
\begin{lstlisting}
(define (even? [n : Int] [k : (-> $\star$ Bool)]) : Bool
  (if (= n 0) (k #t) (odd? (- n 1) k)))
(define (odd? [n : Int] [k : (-> Bool Bool)]) : Bool
  (if (= n 0) (k #f) (even? (- n 1) k)))
\end{lstlisting}
These example programs are adapted from those of Herman et al.~\citep{herman2010space}.
We direct readers to their work for more examples and a detailed explanation.

One solution to this space-efficiency problem is to represent cast
information more concisely. There are several known space-efficient
cast representations
\citep{Siek:2015:BCT:2737924.2737968,Siek:2010:TWB:1706299.1706342,Garcia:2013:CTB:2500365.2500603,kuhlenschmidt2018efficient,siek2012interpretations,garcia2014deriving}.
The current state of the art includes
\begin{itemize}
	\item threesomes 
	\citep{Siek:2010:TWB:1706299.1706342,Garcia:2013:CTB:2500365.2500603},
	\item supercoercions \citep{Garcia:2013:CTB:2500365.2500603}, and
	\item coercions in normal form
	\citep{siek2012interpretations,Siek:2015:BCT:2737924.2737968}.
\end{itemize}

The semantics of these cast representations are defined in many
different papers with separate reduction rules, which makes it
difficult to isolate the key differences between them.  In this paper
we present a set of reduction rules for a cast calculus that
is parameterized over the cast representation
(Section~\ref{sec:framework}).
The semantics takes the form of a CEK
abstract machine and it formulates the interface between the machine
and the different cast representations as an abstract data type,
namely the \emph{Cast ADT}.

Of course, a space-efficient cast representation must be proved
correct. That is, a language implementation that uses space-efficient
casts should give the same output as the language semantics. Our
generic CEK machine comes with generic theorems mechanized in
the Agda proof assistant~\citep{norell2008dependently}
(Section~\ref{sec:framework}) that researchers can use to prove a cast
representation correct.  We believe this framework can reduce the
burden of proving correctness theorems and help people focus on the
cast representations. As a demonstration, we apply the framework to
Lazy UD coercions in normal form~\citep{Siek:2015:BCT:2737924.2737968}
and Lazy UD threesomes~\citep{Siek:2010:TWB:1706299.1706342}. We
believe the framework is also applicable to other cast
representations. The framework and demonstrations are available at the
following URL:
\[\text{\urlFrameworkAndIllustration}\]

The published space-efficient cast representations have various
strengths and weaknesses.  The major insight of these systems is a
compose operator for casts which compresses cast information to reduce
space consumption.  Threesomes and supercoercions are good for
mechanized metatheory because their compose operators 
can be written in a structrually recursive form,
making them easy to define in proof assistants such as
Agda. In contrast, the coercions in normal form have compose operators
that are not structurally recursive, which makes it more difficult to
define in Agda, requiring what amounts to an explicit proof of
termination.
%
On the other hand, coercions in normal form are easier to understand
than threesomes (which have a strange labeled bottom type), and
supercoercions (10 different kinds).

This paper presents a new cast representation named
\emph{hypercoercions}, that is good for both mechanized metatheory and
good for implementation (Section~\ref{sec:hypercoercions}). The
straightforward Agda translation of the composition operator for
hypercoercions is able to pass Agda's termination check and
hypercoercions are suggestive of a bit-level representation that
minimizes the need for pointers and fits all first-order casts into 64
bits.
%
We present two flavors of hypercoercions to support the two blame
tracking strategies from the literature: \LD\ and
\LUD~\citep{siek2009exploring}. With the \LD\ strategy, only 
\textbf{d}own 
casts (casts from \Tdyn\ to some other types) are subject to blame. 
With the 
\LUD\
strategy, however, some \textbf{u}p casts may also be blamed.
We are interested in the D blame
tracking strategy because it comes with a more straightforward notion of
safe cast compared to \LUD~\citep{siek2009exploring}, which is why \LD\ 
was
chosen in the Grift compiler~\citep{kuhlenschmidt2018efficient}. We are also 
interested in \LUD\ because it plays a
prominent role in the gradual typing literature
\citep{wadler2009well}.  The \LUD\ hypercoercions were inspired by the
supercoercions of \citep{Garcia:2013:CTB:2500365.2500603} (hence the name) and
the \LD\ hypercoercions were inspired by the normal forms of
\citet{siek2012interpretations}.
The semantics of casts can be lazy or
eager~\citep{siek2009exploring}. In this paper, we focus on lazy cast
strategies because we suspect that they are more efficient than eager
strategies and because \citet{new2019gradual} show that the eager
strategies are incompatible with $\eta$-equivalence of functions.

To summarize, the primary contributions of this paper are:
\begin{itemize}
\item Cast ADT, an abstract data type for cast representations, and a
  CEK abstract machine parameterized over the Cast ADT,
\item a framework in Agda for proving the correctness of cast
  representations,
\item proofs of correctness in Agda for \LUD\ threesomes,
  \LUD\ coercions in normal form, \LUD\ hypercoercions, and
  \LD\ hypercoercions, 
\item hypercoercions, a new cast representation with a more compact
  memory representation compared to coercions in normal form.
\end{itemize}


\section{Related Work}
\label{chap:related-works}

\todo[inline]{KC: KC, please add \url{https://arxiv.org/abs/2001.11560}
to this section.}

We review closely related work in three areas: coercions in normal
form, threesomes, and parameterized cast calculi.

\subsubsection{Coercions in normal form}

\citet{henglein1994dynamic} introduces coercions to study compilation
from dynamic languages to statically typed
ones. \citet{herman2010space} proposes using coercions in normal forms
to represent casts in gradual typing and proves space efficiency.
However, they did not prove that the coercion-based semantics is
equivalent to the standard (and type-based)
one. \citet{Siek:2015:BCT:2737924.2737968} improve the Lazy UD style
of coercions in normal forms and prove that Lazy UD coercions in
normal form are correct, using two bisimulation between three
reduction semantics. The first semantics is similar to \LUDMachine,
which bisimulates a reduction semantics using coercions (not
necessarily in normal form). The last semantics uses coercions in
normal form and bisimulates the coercions-based semantics.

\todo[inline]{JS: say something about the difference between the above
  and what is in this paper. That's the whole point of the related work
  section from the eyes of the reviewer.}
\todo[inline]{KC: I might have some misconcept about the related work
section. You might have felt this, haha. Now I think this section is
targeting the following scenarios:
- ``I think someone has solved this problem ...''
- ``This work looks similar to paper X, what is the difference?''
- ``Is this work inspired by paper X?''
Is my understanding correct?}

\subsubsection{Threesomes}

\citet{Siek:2010:TWB:1706299.1706342} introduce Lazy UD threesomes and
prove them correct, using a bisimulation between two reduction
semantics: one is analogous to the \LUDMachine; the other uses Lazy UD
threesomes and is analogous to the machine in
Section~\ref{sec:framework}.  \citet{Garcia:2013:CTB:2500365.2500603}
introduces several other flavors of threesomes, including a Lazy D
one. Their threesomes are derived from the corresponding styles of
coercions in normal form, using correctness-preserving
transformation. So the correctness of their threesomes relies on the
correctness of the coercions-in-normal-form-based semantics defined in
\citet{herman2010space}, which has not been proved correct.

\todo[inline]{JS: again, say something about the difference between
  the above and what is in this paper.}

\subsubsection{Parameterized cast calculi}

\citet{garcia2014deriving} presents a dynamic semantics for the Eager
D blame strategy, using coercions. They claim that ``the artefacts for
coercions can be replaced by other artefacts implementing different
dynamic semantics''.

\todo[inline]{JS: The above is too short of a description of that related
work.}


\section{Background} \label{sec:background}

In this section, we first review lazy cast calculi (Subsection~\ref{sec:cast-calculi}), where
we present an abstract machine that is employed in our framework. Then
we review coercions and their normal forms (Subsection~\ref{sec:coercions}), which
motivates and inspires the design of hypercoercions.

\subsection{Cast Calculi} \label{sec:cast-calculi}

\begin{figure}[tp]
Syntax
\[
\begin{array}{lrcl}
\text{Blame Labels} & l,\bar{l} \\
\text{Variables} & x,y,z \\
\stxrule{S,T}{Types}{
	\Tdyn \mid{}
	P
}
\stxrule{P,Q}{Pre-types}{
	\Pbool \mid
	\Pfunc{T}{T} \mid
	\Pprod{T}{T}
}
\stxrule{G,H}{Ground types}{
	\Gbool  \mid
	\Gfunc  \mid
	\Gprod
}
\stxrule{e}{Expressions}{
	\evar{x}        \mid
	\elam{x}{S}{e}  \mid
	\eapp{e}{e}     \mid
	\econs{e}{e}  \mid
	\efst{e}      \mid
	\esnd{e}
}
\stxrulecont{
	\ecast{e}{\ccast{S}{l}{T}}  \mid
	\etrue         \mid
	\efalse        \mid
	\eif{e}{e}{e}
}
\end{array}
\]
	
	\fbox{\consistent{T}{T}} Consistency
	\begin{gather*}
	\infr{}{\consistent{\Tdyn}{\Tdyn}} \quad
	\infr{}{\consistent{\Tdyn}{P}    } \quad
	\infr{}{\consistent{P}{\Tdyn}    }
	\\[1ex]
	\infr{}{
		\consistent{\Pbool}{\Pbool}
	} \quad
	\infr{
		\consistent{S_1}{S_2} &
		\consistent{T_1}{T_2}
	}{
		\consistent{\Pfunc{S_1}{T_1}}{\Pfunc{S_2}{T_2}}
	} \quad
	\infr{
		\consistent{S_1}{S_2} &
		\consistent{T_1}{T_2}
	}{
		\consistent{\Pprod{S_1}{T_1}}{\Pprod{S_2}{T_2}}
	}
	\end{gather*}
		
	\fbox{\shallowlyconsistent{T}{T}} Shallow consistency
	\begin{gather*}
	\inference{}{
		\shallowlyconsistent{\Tdyn}{\Tdyn}
	} \quad
	\inference{}{
		\shallowlyconsistent{\Tdyn}{P}
	} \quad
	\inference{}{
		\shallowlyconsistent{P}{\Tdyn}
	} \\
	\inference{}{
		\shallowlyconsistent{\Pbool}{\Pbool}
	} \quad
	\inference{}{
		\shallowlyconsistent{\Pfunc{S_1}{T_1}}{\Pfunc{S_2}{T_2}}
	} \quad
	\inference{}{
		\shallowlyconsistent{\Pprod{S_1}{T_1}}{\Pprod{S_2}{T_2}}
	}
	\end{gather*}


\fbox{$\expressiontyping{\Gamma}{e}{T}$} Expression Typing
\begin{gather*}
\dots \quad
\infr{
	\expressiontyping{\Gamma}{e}{S}  &
	\consistent{S}{T}
}{
	\expressiontyping{\Gamma}{(\ecast{e}{\ccast{S}{l}{T}})}{T}
}
\end{gather*}

\caption{Syntax and static semantics of the Cast Calculus.}
\label{fig:statics}
\end{figure}

\paragraph{Syntax and Static Semantics}

The syntax and static semantics are the same for the \LD\ and
\LUD\ cast calculi. They are reviewed in \figref{fig:statics}.
As usual, the important features are the cast expressions,
$\ecast{e}{\ccast{S}{l}{T}}$, which are responsible for runtime type
checking. Blame labels can be positive (blaming the expression inside the cast)
or negative (blaming the context outside the cast), as in \cite{wadler2009well}.
The syntax and static semantics is the same as that of 
\citep{siek2009exploring} except for a few minor exceptions:

\begin{itemize}
\item We consider only one base type, Boolean, for simplicity.
\item We add the product type.
\item We separate types into those with a type constructor at the top,
  the \emph{pre-types}, versus the dynamic type \Tdyn.
\end{itemize}
As usual, in a cast $\ecast{e}{\ccast{S}{l}{T}}$, the source type $S$
and the target $T$ must be consistent.

\paragraph{Dynamic Semantics}

The dynamic semantics of a cast calculus is typically defined with a
reduction semantics. Here we use a CEK machine
\citep{felleisen1986control} instead. One reason is that environments
are easier to deal with than substitutions in formal proofs. Also, a
CEK machine is more convenient to use for the space-efficient
semantics in \chapref{sec:framework} because continuations need to be
compressed and continuations are an explicit part of the CEK machine
states.  So also using a CEK machine for the cast calculi in this
section makes it easier to prove these machines are equivalent.  The
equivalence of this CEK machine and reduction semantics for cast
calculi could be proved by standard
techniques~\citep{Felleisen:2009aa}.


\begin{figure}[tp]
\[
\begin{array}{lrcl}
\stxrule{v,u}{Values}{
  	\vdyn{I}{v}  \mid
    \vtrue       \mid
    \vfalse                     
}
\stxrulecont{
    \vfunc{x}{S}{e}{E}  \mid
	\vfuncc{v}{S}{T}{l}{S}{T}
}
\stxrulecont{
    \vcons{v}{v}               \mid
	\vconsc{v}{S}{T}{l}{S}{T}
}
\stxrule{I,J}{Injectable types}{
	\text{a subset of $P$ defined by the blame strategy $B$}
}
\stxrule{E}{Environments}{
	\text{a partial function}\;\{\langle x , v \rangle , \dots \}
}
\stxrule{F}{Frames}{
	\FappXO{e}{E}  \mid
	\FappOX{v}     \mid
	\Fcast{\ccast{S}{l}{T}} \mid
	\Fif{e}{e}{E}
}
\stxrulecont{
	\Ffst \mid
	\Fsnd \mid
	\FconsXO{e}{E}  \mid
	\FconsOX{v}
}
\stxrule{K}{Continuations}{
	\Knil         \mid
	\Kcons{F}{K}
}
\stxrule{s}{States}{
	\sexpr{e}{E}{K}  \mid
	\scont{v}{K}     \mid
	\shalt{v}        \mid
	\error{l}
}
\stxrule{o}{Observables}{
    \odyn    \mid
    \otrue   \mid
    \ofalse  \mid
    \ofunc   \mid
    \ocons   \mid
    \error{l}
}
\stxrule{r}{Cast results}{
    v \mid
    \error{l}
}
\end{array}
\]

\fbox{\valuetyping{v}{T}} Value typing
\begin{gather*}
\dots \qquad
\inference{
	\valuetyping{v}{I}
}{
	\valuetyping{\vdyn{I}{v}}{\Tdyn}
} \\[1ex]
\inference{
	\valuetyping{v}{\Pfunc{S_1}{T_1}}
}{
	\valuetyping{(\vfuncc{v}{S_1}{T_1}{l}{S_2}{T_2})}{\Pfunc{S_2}{T_2}}
} \quad
\inference{
	\valuetyping{v}{\Pprod{S_1}{T_1}}
}{
	\valuetyping{(\vconsc{v}{S_1}{T_1}{l}{S_2}{T_2})}{\Pprod{S_2}{T_2}}
}
\end{gather*}


\fbox{$\proxy{v}{\ccast{S}{l}{T}}=v$}
\[
\begin{array}{rclr}
\figequalto{\proxy{v}{\ccast{\Pbool}{l}{\Pbool}}}{v}{}
\figequalto{\proxy{v}{\ccast{\Pfunc{S_1}{T_1}}{l}{\Pfunc{S_2}{T_2}}}}{
	\vfuncc{v}{S_1}{T_1}{l}{S_2}{T_2}
}{}
\figequalto{\proxy{v}{\ccast{\Pprod{S_1}{T_1}}{l}{\Pprod{S_2}{T_2}}}}{
	\vconsc{v}{S_1}{T_1}{l}{S_2}{T_2}
}{}
\end{array}
\]

\caption{Syntax of a CEK machine \CMachine{B} and auxiliary definitions.}
\label{fig:R-machine-syntax}
\end{figure}

Fig.~\ref{fig:R-machine-syntax} defines machine 
states $s$, including a definition of values $v$ and value typing.
Fig.~\ref{fig:R-machine-dynamics} defines the transition relation of the CEK
machine (\CMachine{B}).
We name the machine after \textbf{c}ast calculus.
%
% This machine is parameterized over blame strategy $B$, which ranges over
% Lazy D (Fig.~\ref{fig:blame-strategy-LazyD}) and Lazy UD 
% (Fig.~\ref{fig:blame-strategy-LazyUD}).
This machine is parameterized over blame strategy $B$. We will describe
the components of a blame strategy as we go through the machine definition.
In this work we focus on Lazy D (Fig.~\ref{fig:blame-strategy-LazyD}) and Lazy UD 
(Fig.~\ref{fig:blame-strategy-LazyUD}). Adding more blame strategies, 
such as the ones defined in \cite{siek2009exploring}, is possible.
\todo[inline]{JS: I don't think $B$ is restricted to just those two.
Can't it be any blame strategy that satisfies certain conditions?}
\todo[inline]{KC: Technically a $B$ should define a predicate over pretypes, which specifies
what is injectable, and a apply-cast function. Of course, the set of values that the apply-cast
function works with depends on the set of injectable types.
\url{https://github.com/Gradual-Typing/Equivalence-of-Cast-Calculi/blob/master/equivalence-of-cast-calculi/R/BlameStrategies.agda}
Do you want me to put these contraints in the paper?}
\todo[inline]{JS: Yes.}
\todo[inline]{KC: The machine definition gives a nice context for blame strategy so I 
define blame strategy later. You will find a todo near the blame strategy definition.}
%
The transitions involving casts are highlighted in red and described in
more detail below. The other transitions are standard for a CEK
machine for an extended simply typed lambda calculus~\citep{Felleisen:2009aa}.
%
Recall that CEK machines involve two kinds of transitions: those that
dive further into an expression (looking for a redex) and push an
entry onto the continuation and those that return a value to the
current continuation and possibly perform a computation.  That is, the
machine state is either in an evaluating $\sexpr{e}{E}{K}$ or
returning $\scont{v}{K}$ configuration, respectively. Additionally,
there are two halting configurations: \shalt{v} halts with a value,
while \error{l} halts with a blame label.  Observables include all the
value constructors and blame labels, as in the work of
\citet{siek2012interpretations}.  The function that converts values to
observables ($observe(v) = o$) is defined in the obvious way.

Let $v$ range over values. The $\vdyn{I}{v}$ stands for values casted
to the dynamic type, as in the work of \citet{wadler2009well}. The
inner value must be of an injectable type ($I$).
% The definition of
% injectable types depends on blame strategies:
The set of injectable type, which is defined by specify blame strategies,
must be a subset of pre-types.
%
For the \LD\ strategy, every pre-type is injectable 
(Fig.~\ref{fig:blame-strategy-LazyD});
%
for the \LUD\ strategy, only ground types are injectable 
(Fig.~\ref{fig:blame-strategy-LazyUD}).
%
Other kinds of values are either Boolean constants, functions, casted 
functions, pairs, or casted pairs.
%
The \proxy{v}{\ccast{S}{l}{T}} partial function applies the cast to $v$, which must
have type $S$. This function is handy when we describe the dynamic semantics.
% In earlier version of this work, 
% we were tempted to use a generic constructor for all casted value, and use 
% value typing rules to restrict the cast such that its source and target are 
% shallowly consistent pre-types. This approach unfortunately considers 
% $\ecast{\etrue}{\ccast{\Pbool}{l}{\Pbool}}$ as a value.

The syntax \error{l} occurs several times in the syntax definition. We shall 
view those nonterminals that have an \error{l} case as error monads. We use 
the symbol \mbind{} as the monad bind operator, which is defined as follows:
\[
\begin{array}{rcll}
(\error{l}) \mbind f & = & \error{l} \\
          a \mbind f & = & f(a)      & \text{otherwise}
\end{array}
\]
\todo[inline]{JS: why not use monadic let instead? That avoids
  the need to also use meta-lambdas, which you would need to
  explain, e.g., in the transition rule that uses applyCast.}
\todo[inline]{KC: 1. I will try to switch to monadic let. As you pointed out
when we wrote the WGT paper, let is more friendly to readers who are not familiar
with monads.
2. Do you imply that monadic let doesn't need to be explained?
}
\todo[inline]{JS: No, you should still define monadic let.}

\begin{figure}[tp]
	\fbox{\reducetoR{B}{s}{s}} Transition
	\[
	\begin{array}{rclr}
	\figreduceto{\sexpr{\evar{x}}{E}{K}}{\scont{E(x)}{K}}{}
	\figreduceto{\sexpr{\elam{x}{S}{e}}{E}{K}}{\scont{\vfunc{x}{S}{e}{E}}{K}}{}
	\figreduceto{\sexpr{\eapp{e_1}{e_2}}{E}{K}}{
		\sexpr{e_1}{E}{\Kcons{\FappXO{e_2}{E}}{K}}
	}{}
	\figreduceto{\sexpr{\etrue}{E}{K}}{\scont{\vtrue}{K}}{}
	\figreduceto{\sexpr{\efalse}{E}{K}}{\scont{\vfalse}{K}}{}
	\figreduceto{\sexpr{\eif{e_1}{e_2}{e_3}}{E}{K}}{
		\scont{e_1}{\Kcons{\Fif{e_2}{e_3}{E}}{K}}
	}{}
	\figreduceto{\sexpr{\econs{e_1}{e_2}}{E}{K}}{
		\sexpr{e_1}{E}{\Kcons{\FconsXO{e_2}{E}}{K}}
	}{}
	\figreduceto{\sexpr{\efst{e}}{E}{K}}{\sexpr{e}{E}{\Kcons{\Ffst}{K}}}{}
	\figreduceto{\sexpr{\esnd{e}}{E}{K}}{\sexpr{e}{E}{\Kcons{\Fsnd}{K}}}{}
	\figreducetoH{
		\sexpr{\ecast{e}{\ccast{S}{l}{T}}}{E}{K}
	}{
		\sexpr{e}{E}{\Kcons{\Fcast{\ccast{S}{l}{T}}}{K}}
	}{}
	\figreducetoH{\scont{v}{\Kcons{\Fcast{\ccast{S}{l}{T}}}{K}}}{
		\applyCast{v}{\ccast{S}{l}{T}} \; \mbind \; \lambda u. \scont{u}{K}
	}{}
	\figreduceto{\scont{v_1}{\Kcons{\FappXO{e_2}{E}}{K}}}{\sexpr{e_2}{E}{
			\Kcons{\FappOX{v_1}}{K}}
	}{}
	\figreduceto{\scont{v}{\Kcons{\FappOX{\vfunc{x}{S}{e}{E}}}{K}}}{
		\sexpr{e}{E[x:=v]}{K}
	}{}
	\figreducetoH{\scont{v}{\Kcons{\FappOX{(\vfuncc{u}{S_1}{T_1}{l}{S_2}{T_2})}}{K}}}{
		\scont{v}{
			\Kcons{\Fcast{\ccast{S_2}{\bar{l}}{S_1}}}{
				\Kcons{\FappOX{u}}{
					\Kcons{\Fcast{\ccast{T_1}{l}{T_2}}}{K}}}}
	}{}
	\figreduceto{\scont{\vtrue}{\Kcons{\Fif{e_2}{e_3}{E}}{K}}}{\sexpr{e_2}{E}{K}}{}
	\figreduceto{\scont{\vfalse}{\Kcons{\Fif{e_2}{e_3}{E}}{K}}}{\sexpr{e_3}{E}{K}}{}
	\figreduceto{\scont{v_1}{\Kcons{\FconsXO{e_2}{E}}{K}}}{
		\sexpr{e_2}{E}{\Kcons{\FconsOX{v_1}}{K}}
	}{}
	\figreduceto{\scont{v_2}{\Kcons{\FconsOX{v_1}}{K}}}{
		\scont{\vcons{v_1}{v_2}}{K}
	}{}
	\figreduceto{\scont{\vcons{v_1}{v_2}}{\Kcons{\Ffst}{K}}}{\scont{v_1}{K}}{}
	\figreducetoH{\scont{\vconsc{u}{S_1}{T_1}{l}{S_2}{T_2}}{\Kcons{\Ffst}{K}}}{
		\scont{u}{
			\Kcons{\Ffst}{
				\Kcons{\Fcast{\ccast{S_1}{l}{S_2}}}{K}}}	
	}{}
	\figreduceto{\scont{\vcons{v_1}{v_2}}{\Kcons{\Fsnd}{K}}}{\scont{v_2}{K}}{}
	\figreducetoH{\scont{\vconsc{u}{S_1}{T_1}{l}{S_2}{T_2}}{\Kcons{\Fsnd}{K}}}{
		\scont{u}{
			\Kcons{\Fsnd}{
				\Kcons{\Fcast{\ccast{T_1}{l}{T_2}}}{K}}}	
	}{}
	\figreduceto{\scont{v}{\Knil}}{\shalt{v}}{}
	\end{array}
	\]
	
	\fbox{\evaltoR{B}{e}{o}} Evaluation
	\[
	\inference{
		\transitivelyreduceto{\sexpr{e}{\emptyset}{\Knil}}{\shalt{v}}
	}{
		\evalto{e}{observe(v)}
	} \quad
	\infr{
		\transitivelyreduceto{\sexpr{e}{\emptyset}{\Knil}}{\error{l}}
	}{
		\evalto{e}{\error{l}}}
	\]
	\caption{Dynamic semantics of the cast calculi as a CEK
		machine \CMachine{B}. The transitions that involve casts are highlighted
		in red.}
	\label{fig:R-machine-dynamics}
\end{figure}

The transition relation \reduceto{s}{s} invokes the cast application
function, noted as $\applyCast{v}{\ccast{S}{l}{T}}$, which is also defined
by specify blame strategies (Fig.~\ref{fig:blame-strategy-LazyD} and
Fig.~\ref{fig:blame-strategy-LazyUD}).
\todo[inline]{JS: be consistent with the font used for applyCast. Sometimes
  you use roman and sometimes you used italic. Also, be consistent
  for all the metafunctions (eval, observe, etc.).}
%
When evaluating a cast expression, the machine moves the cast to the
continuation and evaluates the inner expression.
%
To cast a value, the machine invokes applyCast on the value. The cast
result is either a value or an error (\error{l}). If the cast
succeeds, the machine returns the value to the next continuation.  If
the cast fails, the machine halts with the blame label.
%
To apply a casted function, the machine first casts the argument $v$, then
applies the inner function $u$ to the casted argument, and finally
casts the return value.
%
To project the first element of a casted pair, the machine projects
the first element of the inner pair $u$ and cast it.
%
Projecting the second element of a casted pair is similar.

The reflexive transitive closure of reduction \transitivelyreduceto{s}{s}
and evaluation partial function ${\evalto{e}{o}}$ are standard~\citep{felleisen03:_pllc}.

\begin{figure}[tp]
\[
\begin{array}{lrcl}
\stxrule{I,J}{Injectable types}{P}
\end{array}
\]
	
\fbox{$\mathit{applyCast}_{\BLD}(v,\ccast{S}{l}{T}) = r$}
\[
\begin{array}{rclr}
\figequalto{
	applyCast(v,\ccast{\Tdyn}{l}{\Tdyn})
}{
	\just{v}
}{}
\figequalto{
applyCast(v,\ccast{P}{l}{\Tdyn})
}{
	\just{\vdyn{P}{v}}
}{}
\figequalto{
	applyCast(\vdyn{P}{u},\ccast{\Tdyn}{l}{Q})
}{
	applyCast(u,\ccast{P}{l}{Q})
}{}
\figequalto{
	applyCast(v,\ccast{P}{l}{Q})
}{
	\just{\proxy{v}{\ccast{P}{l}{Q}}}
}{\sidecond{\shallowlyconsistent{P}{Q}}}
\figequalto{
	applyCast(v,\ccast{P}{l}{Q})
}{
	\error{l}
}{\sidecond{\notshallowlyconsistent{P}{Q}}}
\end{array}
\]
\caption{The \LD\ blame strategy (\BLD)}
\label{fig:blame-strategy-LazyD}
\end{figure}

\todo[inline]{KC: conditions of blame strategy}
\begin{definition}[Blame Strategy, $B$]
A blame strategy defines a subset of pre-types, written I, that is injectable,
and a function, written applyCast, that applies cast to values.
\end{definition}

\begin{definition}[\LD\ CEK Machine, \LDMachine]
The \LD\ CEK machine, written \LDMachine, is the CEK machine of
\figref{fig:R-machine-dynamics} using the \BLD\ blame strategy defined in 
\figref{fig:blame-strategy-LazyD}.  We write the transition relations of
this machine as \reducetoD{s}{s} and \transitivelyreducetoD{s}{s}
and the evaluator as \evaltoD{e}{o}.
\end{definition}

We conjecture that \LDMachine\ is equivalent to the \LD\ cast calculus
of \citet{siek2009exploring}.

The \LDMachine{} machine is deterministic.

\begin{proposition}[\LDMachine\ is deterministic]
	If \reducetoD{s}{s_1} and \reducetoD{s}{s_2} then $s_1 = s_2$.
\end{proposition}

Next, we define the CEK Machine for \LUD. The only differences with
respect to \LD\ are in the injectable types and in
${\mathit{applyCast}(v,\ccast{S}{l}{T})}$, in which a cast whose
source or target is the dynamic type \Tdyn\ is always split into two
casts that go through a ground type, that is, a type whose
sub-components are the dynamic type, such as \Pfunc{\Tdyn}{\Tdyn}.
\begin{definition}[\LUD\ CEK Machine]
	The \LUD\ CEK machine, written \LUDMachine\, is the CEK machine of
	\figref{fig:R-machine-dynamics} using the \BLUD\ blame strategy defined in 
	\figref{fig:blame-strategy-LazyUD}.  We write the transition relations of
	this machine as \reducetoUD{s}{s} and \transitivelyreducetoUD{s}{s}
	and the evaluator as \evaltoUD{e}{o}.
\end{definition}

\begin{figure}[tp]
\[
\begin{array}{lrcl}
\stxrule{I,J}{Injectable types}{G}
\end{array}
\]

	\fbox{$\mathit{applyCast}_{\mathtt{\BLUD}}(v,\ccast{S}{l}{T}) = r$}
	\[
	\begin{array}{rclr}
	\mathit{applyCast}(v, \ccast{\Tdyn}{l}{\Tdyn}) &=& \just{v} \\
	\mathit{applyCast}(v, \ccast{G}{l}{\Tdyn}) &=&
	\just{\vdyn{G}{v}} \\
	\mathit{applyCast}(v, \ccast{P}{l}{\Tdyn}) &=&
	\just{\vdyn{G}{\proxy{v}{\ccast{P}{l}{G}}}}
	\\ && \text{if } G \sim P, G \neq P \\  
% 	& \text{if } G \sim P, G \neq P \\  
	\mathit{applyCast}(\vdyn{G}{u}, \ccast{\Tdyn}{l}{H}) &=&          
	\project{u}{G}{l}{H}\\
	\mathit{applyCast}(\vdyn{G}{u}, \ccast{\Tdyn}{l}{Q}) &=&
	\project{u}{G}{l}{H} \mbind \lambda v. \proxy{v}{\ccast{H}{l}{Q}}
	\\
	&& \text{if } H \sim Q, H \neq Q \\
% 	& \text{if } H \sim Q, H \neq Q \\
	\mathit{applyCast}(v, \ccast{P}{l}{Q}) &=&
	\just{\proxy{v}{\ccast{P}{l}{Q}}}
	\\&& \text{if } P \smile Q \\
	\mathit{applyCast}(v, \ccast{P}{l}{Q}) &=&
	\error{l}
	\\&& \text{if } P \not\smile Q
	\end{array}
	\]
	
	\fbox{$\project{v}{G}{l}{H}=r$}
	\[
	\begin{array}{rclr}
	\figequalto{\project{v}{G}{l}{G}}{v}{}
	\figequalto{\project{v}{G}{l}{H}}{\error{l}}{\sidecond{G \neq H}}
	\end{array}
	\]
	
\caption{The \LUD\ blame strategy (\BLUD)}
	\label{fig:blame-strategy-LazyUD}
\end{figure}

We conjecture that \LUDMachine\ is equivalent to the \LUD\ cast
calculus of \citet{siek2009exploring}.

The \LUDMachine{} machine is deterministic.

\begin{proposition}[\LUDMachine\ is deterministic]
	If $\reducetoUD{s}{s_1}$ and $\reducetoUD{s}{s_2}$ 
	then $s_1 = s_2$.
\end{proposition}

\subsection{Coercions and Normal Forms} 
\label{sec:coercions}

In this section, we review the coercions
of~\citet{henglein1994dynamic} and \citet{herman2010space} and the
normal form of \citet{siek2012interpretations} to motivate the design
of hypercoercions.

\begin{figure}[tp]
	\[
	\begin{array}{lrcl}
	\stxrule{I,J}{Injectable types (\LD)}{P}
	\stxrule{I,J}{Injectable types (\LUD)}{G}
	\stxrule{c,d}{Coercions}{
		\cnfid{T}       \mid
		\cnffunc{c}{d}  \mid
		\cnfprod{c}{d}  \mid
		\cnffail{l}     \mid
		\cnfinj{I}      \mid
		\cnfproj{I}{l}  \mid
		\cnfseq{c}{d}
	}
	\stxrule{s,t}{Coercions in normal form}{
		\cnfid{\Tdyn}       \mid
		\cnfseq{\cnfproj{I}{l}}{i} \mid
		i
	}
	\stxrule{i}{Final Coercions}{
		\cnffail{l} \mid
		\cnfseq{g}{\cnfinj{I}} \mid
		g
	}
	\stxrule{g}{Middle Coercions}{
		\cnfid{\Pbool} \mid
		\cnffunc{s}{t} \mid
		\cnfprod{s}{t}
	}
	\end{array}
	\]
	\caption{Syntax of coercions and normal forms {\`a} la 
		\citet{siek2012interpretations}.}
	\label{fig:normal-coercion}
\end{figure}

\figref{fig:normal-coercion} reviews the grammar for coercions,
written $c$.
%
To review, an injection $\cnfinj{I}$ takes a value from an injectable type
$I$ to type $\Tdyn$. An injectable type is simply a type that can be
cast directly to and from $\Tdyn$. The
definition of injectable types depends on the blame strategy, as in 
Subsection~\ref{sec:cast-calculi}.
%
A projection $I?^l$ takes a value from type $\Tdyn$ to type $I$, or
halts the program and blames $l$ if the value is inconsistent with 
the target type.
The coercion \cnfid{T} is the identity, $\bot^{l}$ is the coercion that
always fails and blames $l$, and $(\cnfseq{c}{d})$ applies $c$ and
then $d$ in sequence. The function coercion $\cnffunc{c}{d}$
applies $c$ to the argument of a function and $d$ to the return
value.

Coercions come with a reduction relation so it is natural to ask about
their normal forms. \figref{fig:normal-coercion} defines the syntax of
coercion in normal form, written $s$ and $t$.  Conceptually, a
coercion in normal form has three parts, all of which are optional.
It may start with a projection $I?^l$, followed by a function
coercion, and then concluded with an injection $I!$ or a failure
$\bot^l$. While this is a simple idea, the three-part symmetric
structure is not obvious in the syntax definition.

\section{A Framework for Proving Correctness of Cast ADTs}
\label{sec:framework}

% All cast representation shall be proved correct, that is, besides reducing 
% space consumption, using a cast representation should not affect the results of 
% program execution.
In this section we present a framework for proving the correctness of
space-efficient cast representations.  The framework includes an
abstract data type named Cast ADT, which specifies the operators
required of a cast representation, a CEK machine $\SMachine{C}$
parameterized over a Cast ADT $C$, and theorems relating
$\SMachine{C}$ to $\CMachine{B}$.
%
Subsection~\ref{sec:cast-adt-and-space-efficient-cek} defines the Cast
ADT and the machine \SMachine{C}. We conjecture that the machine
\SMachine{C} is space-efficient provided that the cast representation
$C$ performs compression.
%
Subsection~\ref{sec:good-cast-adt} defines two subsets of the Cast
ADT, namely the Lazy D Cast ADT and the Lazy UD Cast ADT. As their
names suggest, if $C$ is a Lazy D Cast ADT, executing a program in
$\SMachine{C}$ would give the same result as in
$\LDMachine$. Similarly, if $C$ is a Lazy UD Cast ADT, executing a
program in $\SMachine{C}$ would give the same result as in
$\LUDMachine$.
%
We prove the theorems relating \SMachine{C} and \CMachine{B} in
Subsection~\ref{sec:S-correct}.

%In Section~\ref{chap:background} we have seen that the standard dynamic 
%semantic of the cast calculi has a space-efficiency problem 
%(Section~\ref{sec:space-efficiency-problem}): casts might accumulate in 
%higher-order values and continuations and consume unbounded space. The 
%solution 
%is space-efficient cast representations, such as coercions in normal form and 
%threesomes.
%%
%Every such cast representations shall be proved correct. Actually, 
%people have done such proofs several times, such as the \emph{Correctness of 
%the threesome calculus} in \citep{Siek:2010:TWB:1706299.1706342} and the 
%bisimulation theorems in \citep{Siek:2015:BCT:2737924.2737968}.
%%
%These theorems are similar -- conceptually the only difference is the cast 
%representation.
%%
%But having two proofs blurs the similarity between the proofs and the key 
%differences between cast representations. 
%%
%Furthermore, there might be more cast representations in the future.
%Actually we introduce a new one in Section~\ref{chap:hypercoercions}.
%%
%Consequently, it is desirable to have generic proofs that handles many cast 
%representations that implement a common interface.
%
%Our solution is an abstract data type (Cast ADT), which specifies the 
%operators 
%of cast representations and a CEK machine ($\SMachine{C}$) parameterized over 
%Cast ADT (Section~\ref{sec:cast-adt-and-space-efficient-cek}). Then we 
%prove that if $C$ is a Lazy D Cast ADT then \SMachine{C} is equivalent to 
%\LDMachine, and that if $C$ is a Lazy UD Cast ADT then \SMachine{C} is 
%equivalent to \LUDMachine.
%%
%We conjecture that the machine \SMachine{C} is space-efficient provided that 
%the cast representation $C$ performs compression. We will prove or 
%conjecture that all cast representations defined 
%in the literature are instances of this ADT. 
%In \secref{sec:LazyD-correct} we prove that, for any
%instance $C$ of the Cast ADT, if $C$ satisfies a more refined abstract
%data type for Lazy D casts, then \SMachine{C} is equivalent to
%\LDMachine, that is, 
%\[
%\machineequiv{\LDMachine}{\SMachine{C}}
%\]
%In Section~\ref{sec:LazyUD-correct} we prove a corresponding \LUD\ theorem, 
%that is, for any instance $C$ of the Cast ADT, if $C$ satisfies a more refined 
%abstract data type for \LUD\ casts
%\[
%\machineequiv{\LUDMachine}{\SMachine{C}}
%\]
%
%Finally, we prove that some cast representations in 
%the literature (\LD\ and \LUD\ coercions in normal form, and \LUD\ threesomes) 
%are either instances of the Lazy D Cast ADT or the Lazy UD Cast ADT 
%(\secref{sec:coercions-correct} and \secref{sec:threesomes-correct}).
%We conjecture that supercoercions also fit into the two category.

\subsection{Cast Abstract Data Type and a Space-efficient CEK Machine}
\label{sec:cast-adt-and-space-efficient-cek}

\begin{figure}[tp]
	\[
	\begin{array}{lrcl}
	\stxrule{c,d}{Runtime casts}{\text{a data type defined by the 
	instance of Cast ADT}}
	\stxrule{v,u}{Values}{
		\vdyn{I}{v}  \mid
		\vtrue       \mid
		\vfalse                     
	}
	\stxrulecont{
		\ecast{\vfunc{x}{S}{e}{E}}{\Pfunc{c}{c}} \mid
		\ecast{\vcons{v}{v}}{\Pprod{c}{c}}
	}
	\stxrule{I,J}{Injectable types (\LD)}{P}
	\stxrule{I,J}{Injectable types (\LUD)}{G}
	\stxrule{E}{Environments}{
		\text{a partial function}\;\{\langle x , v \rangle , \dots \}
	}
	\stxrule{F}{Frames}{
		\FappXO{e}{E}  \mid
		\FappOX{v}     \mid
		\Fif{e}{e}{E}
	}
	\stxrulecont{
		\Ffst \mid
		\Fsnd \mid
		\FconsXO{e}{E}  \mid
		\FconsOX{v}
	}
	\stxrule{K}{Continuations}{
		\Kcons{\Fcast{c}}{k}
	}
	\stxrule{k}{Pre-continuations}{
		\Knil         \mid
		\Kcons{F}{K}
	}
	\stxrule{s}{States}{
		\sexpr{e}{E}{K}  \mid
		\scont{v}{K}     \mid
		\shalt{v}        \mid
		\error{l}
	}
	\stxrule{r}{Cast results}{
		v \mid
		\error{l}
	}
	\end{array}
	\]
	
	\caption{Syntax of the space-efficient machine \SMachine{C} and auxiliary 
	data structures.}
	\label{fig:SEMachine-state}
\end{figure}

\figref{fig:SEMachine-state} defines the syntax of the space-efficient
CEK machine \SMachine{C}.  The key differences between \SMachine{C}
and \CMachine{B} are in the places where casts can accumulate, that
is, in the definitions of values and continuations.

Let $u,v$ range over values.
%
Recall that in \CMachine{B} we have two value constructors for
functions and another two for pairs. That setup allows zero-or-more
layers of casts at the top of higher-order values, which can consume
unbounded space.
%
\SMachine{C} instead has exactly one layer of cast.
Thus non-casted values in \CMachine{B} correspond to \SMachine{C} values
where casts are identities ($\mathit{id}(T)$). The 
$\mathit{id}$ functions is provided by the Cast ADT.

Let $K$ ranges over continuations and $k$ ranges over
pre-continuations.  This setup requires cast frames and non-cast
frames to alternate in continuations, and that a continuation always
starts with a cast frame.
% %
% Pre-continuations are like the continuations in \CMachine{B}, but their 
% top-most frame must not be a cast frames.
% %
% A continuation is now a pre-continuation prefixed with a cast frame.
% %
% Recall that continuations in \CMachine{B} have zero or more casts at the top.
% In \SMachine{C}, however, every continuation has exactly one cast at the 
% top.
% %
A \CMachine{B} continuation that does not have a cast at the top
corresponds to a \SMachine{C} continuation whose casts are identities.
A \CMachine{B} continuation that has many casts at the top corresponds
to a \SMachine{C} continuation in which those casts are composed by
$\compose{c}{c}$, which is an operation provided by the Cast ADT.
%
Injectable types, environments, states, and cast results are the same
as in \CBMachine.

Value typing (\valuetyping{v}{T}), continuation typing
(\casttyping{k}{S}{T} and \casttyping{K}{S}{T}), and environment
typing (\envtyping{\Gamma}{E}) are defined in the obvious way.  They
rely on cast typing \casttyping{c}{S}{T}, which is provided by the
Cast~ADT.

\todo[inline]{KC: I changed some wording in the following definition:
"a family"; translate a cast ...}
\begin{definition}[Cast Abstract Data Type (Cast ADT)]
	\label{def:cast-rep}
	A cast abstract data type is a family, namely $Cast$, indexed by two types, 
	with four operators and two properties of operators:
\begin{itemize}
	\item $\id{T}=c$: create an identity cast
	\item $\compose{c}{c}=c$: compose casts
	\item $\translate{\ccast{S}{l}{T}}=c$: translate a cast in source 
		program to a $\textit{Cast}_{S,T}$
	\item $\denote{c}(v)=r$: apply a cast to a value
	\item If $ \valuetyping{v}{T} $ then $\denote{\id{T}}(v)=v$
	\item If $ \valuetyping{v}{T_1} $ and
		$ \casttyping{c}{T_1}{T_2} $ and
		$ \casttyping{d}{T_2}{T_3} $ 
		then 
		$ \denote{\compose{c}{d}}(v) = (\denote{c}(v)\mbind\denote{d})$
\end{itemize}
We use the syntax \casttyping{c}{S}{T} to mean $c$ is in the set 
$\textit{Cast}_{S,T}$.
\end{definition}

Before discussing the transition relation of \SMachine{C}, we define
two helper functions for manipulating continuations.
%
The function $\mkContName$ constructs a continuation from a
pre-continuation by topping it with an identity cast.
\begin{align*}
  \mkCont{k} &= \Kcons{\Fcast{\id{S}}}{k} & \sidecond{\casttyping{k}{S}{T}}
\end{align*}
The function $\extContName$ composes $c$ with the cast at the top of
$K$ by using the composition operator $\fatsemi$.
\begin{align*}
  \extCont{c}{\Kcons{\Fcast{d}}{k}} &= \Kcons{\Fcast{(\compose{c}{d})}}{k}
\end{align*}

\begin{figure}[tp]
	\fbox{\reducetoS{C}{s}{s}} Transition
	\[
	\begin{array}{rclr}
	\figreduceto{\sexpr{\evar{x}}{E}{K}}{\scont{E(x)}{K}}{}
	\figreducetoH{
		\sexpr{\elam{x}{S}{e}}{E}{K}
	}{
		\scont{\ecast{\vfunc{x}{S}{e}{E}}{\Pfunc{id(S)}{id(T)}}}{K}
	}{}
	& &
	\highlight{
	\sidecond{
		\expressiontyping{\Gamma,S}{e}{T}
		\text{ and }
		\Gamma \vdash E}
	}
	\\
	\figreduceto{\sexpr{\eapp{e_1}{e_2}}{E}{K}}{
		\sexpr{e_1}{E}{\mkCont{\Kcons{\FappXO{e_2}{E}}{K}}}
	}{}
	\figreduceto{\sexpr{\etrue}{E}{K}}{\scont{\vtrue}{K}}{}
	\figreduceto{\sexpr{\efalse}{E}{K}}{\scont{\vfalse}{K}}{}
	\figreduceto{\sexpr{\eif{e_1}{e_2}{e_3}}{E}{K}}{
		\sexpr{e_1}{E}{\mkCont{\Kcons{\Fif{e_2}{e_3}{E}}{K}}}
	}{}
	\figreduceto{\sexpr{\econs{e_1}{e_2}}{E}{K}}{
		\sexpr{e_1}{E}{\mkCont{\Kcons{\FconsXO{e_2}{E}}{K}}}
	}{}
	\figreduceto{\sexpr{\efst{e}}{E}{K}}{
		\sexpr{e}{E}{\mkCont{\Kcons{\Ffst}{K}}}
	}{}
	\figreduceto{\sexpr{\esnd{e}}{E}{K}}{
		\sexpr{e}{E}{\mkCont{\Kcons{\Fsnd}{K}}}
	}{}
	\figreducetoH{
		\sexpr{\ecast{e}{\ccast{S}{l}{T}}}{E}{K}
	}{
		\sexpr{e}{E}{\extCont{\translate{\ccast{S}{l}{T}}}{K}}
	}{}
	\figreducetoH{\scont{v}{\Kcons{\Fcast{c}}{k}}}{
		\denote{c}(v) \; \mbind \; \lambda u. \applyCont{u}{K}
	}{}
	\end{array}
	\]
	
	\fbox{$\applyCont{v}{k}=s$}
	\[
	\begin{array}{rclr}
	\figequalto{\applyCont{v_1}{\Kcons{\FappXO{e_2}{E}}{K}}}{\sexpr{e_2}{E}{
			\mkCont{\Kcons{\FappOX{v_1}}{K}}}
	}{}
	\figequaltoH{
		\applyCont{v}{\Kcons{\FappOX{(\ecast{\vfunc{x}{S}{e}{E}}{\Pfunc{c}{d}})}}{K}}
	}{
		\denote{c}(v) \mbind \lambda u. \
		\sexpr{e}{E[x:=u]}{\extCont{d}{K}}
	}{}
	\figequalto{\applyCont{\vtrue}{\Kcons{\Fif{e_2}{e_3}{E}}{K}}}{\sexpr{e_2}{E}{K}}{}
	\figequalto{\applyCont{\vfalse}{\Kcons{\Fif{e_2}{e_3}{E}}{K}}}{\sexpr{e_3}{E}{K}}{}
	\figequalto{\applyCont{v_1}{\Kcons{\FconsXO{e_2}{E}}{K}}}{
		\sexpr{e_2}{E}{\mkCont{\Kcons{\FconsOX{v_1}}{K}}}
	}{}
	\figequaltoH{\applyCont{v_2}{\Kcons{\FconsOX{v_1}}{K}}}{
		\scont{\ecast{\vcons{v_1}{v_2}}{\Pprod{\id{T_1}}{\id{T_2}}}}{K}
	}{}
	& & 
	\highlight{\sidecond{
%		\casttyping{K}{\Pprod{T_1}{T_2}}{T'}
		\valuetyping{v_1}{T_1}
		\text{ and }
		\valuetyping{v_2}{T_2}
	}}
	\\
	\figequaltoH{
		\applyCont{\ecast{\vcons{v_1}{v_2}}{\Pprod{c_1}{c_2}}}{\Kcons{\Ffst}{K}}
	}{
		\denote{c_1}(v_1) \mbind \lambda u.
		\scont{u}{K}
	}{}
	\figequaltoH{
		\applyCont{\ecast{\vcons{v_1}{v_2}}{\Pprod{c_1}{c_2}}}{\Kcons{\Fsnd}{K}}
	}{
		\denote{c_2}(v_2) \mbind \lambda u.
		\scont{u}{K}
	}{}
	\figequalto{\applyCont{v}{\Knil}}{\shalt{v}}{}
	\end{array}
	\]
	
	\fbox{\evalto{e}{o}} Evaluation
	\[
	\inference{
		\transitivelyreduceto{\sexpr{e}{\emptyset}{\mkCont{\Knil}}}{\shalt{v}}
	}{
		\evalto{e}{observe(v)}
	} \quad
	\infr{
		\transitivelyreduceto{\sexpr{e}{\emptyset}{\Knil}}{\error{l}}
	}{
		\evalto{e}{\error{l}}}
	\]
	\caption{The space-efficient CEK machine, \SMachine{C}.
          The transitions involving casts are highlighted in red.}
	\label{fig:semachine-dynamics}
\end{figure}

\figref{fig:semachine-dynamics} defines the transition relation
$\reducetoS{C}{s}{s}$. It relies on the functions provided by the Cast
ADT $C$.
%
We focus on the transition rules highlighted in red, which involve
casts and the changes needed for space efficiency.
%
The rule for evaluating a function produces a function value, using
identities for the casts on the function value's domain and range.
%
The rule for evaluating a cast expression extends the continuation
with the cast \translate{\ccast{S}{l}{T}}.
%
The rule for returning a value to a continuation first applies the top
cast of the continutation to the value. If the cast application fails,
the machine halts with the blame label from the failure. Otherwise,
the machine handles the pre-continuation with the function
$\applyCont{v}{k}$.

Turning to the definion of $\applyContName{}$, we again focus on the
cases that are specific to casts and space efficiency.  In the case
for a function value, the machine applies the domain cast $c$ to the
argument $v$ and then begins evaluation of the function body. To
ensure space efficiency, the codomain cast $d$ is merged into the
continuation with $\mathrm{extK}$.
%
In the case for constructing a pair, $\applyContName$ fills the casts
in the pair value with identities, similar to its treatment of
function values.
%
To project the first element of a pair, the machine applies the first
pending cast on the first value and returns the result to the
continuation.
%
Projecting the second element of a pair is similar.

The reflexive transitive closure of reduction $\reducetoS{C}{s}{s}$
and the evaluation partial function $\evaltoS{C}{e}{o}$ are defined in
the standard way~\citep{felleisen03:_pllc}.

\begin{proposition}[\SMachine{C} is deterministic]
	\label{prop:SEMachine-deterministic}
	If $\reducetoS{C}{s}{s_1}$ and $\reducetoS{C}{s}{s_2}$ 
	then $s_1 = s_2$.
\end{proposition}

\subsection{Specifying good instances of the Cast ADT} \label{sec:good-cast-adt}

Recall that our goal is to prove that \SMachine{C} is equivalent to
\LDMachine\ or \LUDMachine\ when $C$ satisfies some properties. The
Cast ADT specifies the behavior of identity casts and composition, so
the only remaining operator to specify is translation:
$\translate{\ccast{S}{l}{T}}$.
%
Lazy D Cast ADT (Definition~\ref{def:LazyD-CastADT}) and Lazy UD Cast ADT 
(Definition~\ref{def:LazyUD-CastADT}) specify the behavior 
of \translate{\ccast{S}{l}{T}}. Readers are encouraged to compare them with the 
corresponding $\mathrm{applyCast}$ functions 
(Fig.~\ref{fig:blame-strategy-LazyD} and 
Fig.~\ref{fig:blame-strategy-LazyUD}).
\todo[inline]{JS: what does ``them'' refer to in the previous sentence?
  Please replace with a specific noun. Also, why should the reader do
  the comparison? What are they suppose to notice?}
\todo[inline]{JS: say where the following equations come from.
  They are the equations you needed for the proof of equivalence,
  right?}

\begin{definition}[Lazy D Cast ADT]
	\label{def:LazyD-CastADT}
	A Cast ADT is a Lazy D Cast ADT if:
	\begin{enumerate}
		\item $\denote{\translate{\ccast{\Tdyn}{l}{\Tdyn}}}(v) = v$
		\item $\denote{\translate{\ccast{P}{l}{\Tdyn}}}(v) = \vdyn{P}{v}$
		\item $\denote{\translate{\ccast{\Tdyn}{l}{Q}}}(\vdyn{P}{u}) = 
		\denote{\translate{\ccast{P}{l}{Q}}}(u)$
		\item $\denote{\translate{\ccast{\Pbool}{l}{\Pbool}}}(v) = v$
		\item 
		$\denote{\translate{\ccast{\Pfunc{S_1}{T_1}}{l}{\Pfunc{S_2}{T_2}}}}(
			\ecast{\vfunc{x}{S}{e}{E}}{\Pfunc{c}{d}})$\\
		$=
		\ecast{\vfunc{x}{S}{e}{E}}{
			\Pfunc{
				(\compose{\translate{\ccast{S_2}{\bar{l}}{S_1}}}{c})}{
				(\compose{d}{\translate{\ccast{T_1}{l}{T_2}}})}}$
		\item 
		$\denote{\translate{\ccast{\Pprod{S_1}{T_1}}{l}{\Pprod{S_2}{T_2}}}}(
		\ecast{\vcons{v_1}{v_2}}{\Pprod{c}{d}})$\\
		$=
		\ecast{\vcons{v_1}{v_2}}{
			\Pprod{
				(\compose{c}{\translate{\ccast{S_1}{l}{S_2}}})}{
				(\compose{d}{\translate{\ccast{T_1}{l}{T_2}}})}}$
		\item $\denote{\translate{\ccast{P}{l}{Q}}}(v) = \error{l}$\\
			if $\notshallowlyconsistent{P}{Q}$
	\end{enumerate}
\end{definition}

\begin{definition}[Lazy UD Cast ADT]
	\label{def:LazyUD-CastADT}
	A Cast is a Lazy UD Cast if:
	\begin{enumerate}
	\item $\denote{\translate{\ccast{\Tdyn}{l}{\Tdyn}}}(v) = v$
	\item $\denote{\translate{\ccast{G}{l}{\Tdyn}}}(v) = \vdyn{G}{v}$
	\item $\denote{\translate{\ccast{P}{l}{\Tdyn}}}(v) = 
		\denote{\translate{\ccast{P}{l}{G}}}(v) \mbind 
		\denote{\ccast{G}{l}{\Tdyn}}$\\
		if $G \sim P$ and $G \neq P$	
	\item $\denote{\translate{\ccast{\Tdyn}{l}{G}}}(\vdyn{G}{u}) = u$
	\item $\denote{\translate{\ccast{\Tdyn}{l}{H}}}(\vdyn{G}{u}) = \error{l}$\\
		if $G \neq H$
	\item $\denote{\translate{\ccast{\Tdyn}{l}{Q}}}(v) = 
		\denote{\translate{\ccast{\Tdyn}{l}{H}}}(v) \mbind
		\denote{\translate{\ccast{H}{l}{Q}}}$\\
		if $H \sim Q$ and $H \neq Q$
	\item $\denote{\translate{\ccast{\Pbool}{l}{\Pbool}}}(v) = v$
		\item 
		$\denote{\translate{\ccast{\Pfunc{S_1}{T_1}}{l}{\Pfunc{S_2}{T_2}}}}(
		\ecast{\vfunc{x}{S}{e}{E}}{\Pfunc{c}{d}})$\\
		$=
		\ecast{\vfunc{x}{S}{e}{E}}{
			\Pfunc{
				(\compose{\translate{\ccast{S_2}{\bar{l}}{S_1}}}{c})}{
				(\compose{d}{\translate{\ccast{T_1}{l}{T_2}}})}}$
		\item 
		$\denote{\translate{\ccast{\Pprod{S_1}{T_1}}{l}{\Pprod{S_2}{T_2}}}}(
		\ecast{\vcons{v_1}{v_2}}{\Pprod{c}{d}})$\\
		$=
		\ecast{\vcons{v_1}{v_2}}{
			\Pprod{
				(\compose{c}{\translate{\ccast{S_1}{l}{S_2}}})}{
				(\compose{d}{\translate{\ccast{T_1}{l}{T_2}}})}}$
		\item $\denote{\translate{\ccast{P}{l}{Q}}}(v) = \error{l}$\\
			if $\notshallowlyconsistent{P}{Q}$
	\end{enumerate}
\end{definition}

\subsection{The Space-efficient CEK Machine is Correct}
\label{sec:S-correct}

Now we are ready to prove that if $C$ is a Lazy D Cast ADT then
\[
\machineequiv{\LDMachine}{\SMachine{C}}
\]
and that if $C$ is a Lazy UD Cast ADT then
\[
\machineequiv{\LUDMachine}{\SMachine{C}}
\]

\begin{figure}[tp]

\fbox{\bisimc{\overline{\ccast{S}{l}{T}}}{c}{S}{T}}
\begin{gather*}
\infr{}{\bisimc{[]}{id(T)}{T}{T}} \quad
\infr{}{\bisimc{[\ccast{S}{l}{T}]}{\translate{\ccast{S}{l}{T}}}{S}{T}}
\\[1ex]
%\infr{
%	\bisimc{z_1}{c_1}{T_1}{T_2}\\
%	\bisimc{z_2}{c_2}{T_2}{T_3}
%}{
%	\bisimc{(z_1 + z_2)}{(\compose{c_1}{c_2})}{T_1}{T_n}
%}
\infr{
	\bisimc{
		(\ccast{T_1}{l_1}{}\ldots\ccast{}{l_{i-1}}{T_i})
	}{c_1}{T_1}{T_i}\\
	\bisimc{
		(\ccast{T_i}{l_i}{}\ldots\ccast{}{l_{n-1}}{T_n})
	}{c_2}{T_i}{T_n}
}{
	\bisimc{
		(\ccast{T_1}{l_1}{}\ldots\ccast{}{l_{n-1}}{T_n})
	}{
		(\compose{c_1}{c_2})
	}{T_1}{T_n}
}
\end{gather*}

\fbox{$\bisimK{K}{K}{S}{T}$}
\begin{gather*}
\infr{
	\bisimK{K}{k'}{S_n}{T} \qquad
	\bisimc{
		(\ccast{S_1}{l_1}{S_2} \ldots \ccast{S_{n-1}}{l_{n-1}}{S_n})
	}{c}{S_1}{S_n}
}{
	\bisimK{
		\Kcons{
			\Fcast{\ccast{S_1}{l_1}{S_2}}
		}{\ldots\Kcons{\Fcast{\ccast{S_{n-1}}{l_{n-1}}{S_n}}}{K}}
	}{
		\Kcons{\Fcast{c'}}{k'}
	}{S_1}{T}
}
\end{gather*}

\fbox{$\bisimv{v}{v}{T}$}
\begin{gather*}
\infr{
	\expressiontyping{\Gamma,x : S_1}{e}{T_1}
	\qquad
	\bisimE{\Gamma}{E}{E'}
	\\
	\bisimc{
		(\ccast{S_n}{\bar{l}_{n-1}}{S_{n-1}} \ldots
		\ccast{S_2}{\bar{l}_1}{S_1})
	}{c}{S_n}{S_1}
	\\
	\bisimc{
		(		\ccast{T_1}{l_{1}}{T_2} \ldots
		\ccast{T_{n-1}}{l_{n-1}}{T_n}
		)	}{d}{T_1}{T_n}
	\\
	v = \vfuncc{
		\vfuncc{
			\vfunc{x}{S_1}{e}{E}
		}{S_1}{T_1}{l_1}{S_2}{T_2}
		\ldots
	}{S_{n-1}}{T_{n-1}}{l_{n-1}}{S_n}{T_n}
}{
	\bisimv{v}{
		(\ecast{\vfunc{x}{S_1}{e}{E'}}{\Pfunc{c}{d}})
	}{
		\Pfunc{S_n}{T_n}}
}
\\[1ex]
\infr{
	\bisimv{v_1}{v_1'}{S_1} \qquad
	\bisimv{v_2}{v_2'}{T_1} \\
	\bisimc{
		(\ccast{S_1}{l_{1}}{S_2} \ldots
		\ccast{S_{n-1}}{l_{n-1}}{S_n})
	}{c}{S_1}{S_n} \\
	\bisimc{
		(\ccast{T_1}{l_{1}}{T_2} \ldots
		\ccast{T_{n-1}}{l_{n-1}}{T_n})
	}{d}{T_1}{T_n}
	\\ v = \vconsc{
		\vconsc{
			\vcons{v_1}{u_1}
		}{S_1}{T_1}{l_1}{S_2}{T_2}
		\ldots
	}{S_{n-1}}{T_{n-1}}{l_{n-1}}{S_n}{T_n}
}{
	\bisimv{
		v
	}{
		(\ecast{\vcons{v_2}{u_2}}{\Pprod{c}{d}})
	}{
		\Pprod{S_n}{T_n}}
}
\end{gather*}
	
\fbox{\bisimE{\Gamma}{E}{E}}
\begin{gather*}
\inference{
}{
	\bisimE{\emptyset}{\emptyset}{\emptyset}
}
\quad
\inference{
	\Gamma \vdash E \approx E' \qquad
	v \approx v' : T
}{
	\Gamma , x : T \vdash 
	E [ x := v' ] \approx E' [ x := v' ]
}
\end{gather*}

\fbox{\bisims{s}{s}{T}}
\begin{gather*}
\infr{}{\bisims{\error{l}}{\error{l}}{T}} \quad
\infr{
	\bisimv{v}{v'}{T}
}{
	\bisims{\shalt{v}}{\shalt{v'}}{T}
}
\\
\infr{
	\bisimv{v}{v'}{S} \\
	\bisimK{K}{K'}{S}{T}
}{
	\bisims{\scont{v}{K}}{\scont{v'}{K'}}{T}
} \quad
\infr{
	\expressiontyping{\Gamma}{e}{S} \\
	\bisimE{\Gamma}{E}{E'}          \\
	\bisimK{K}{K'}{S}{T}
}{
	\bisims{\sexpr{e}{E}{K}}{\sexpr{e}{E'}{K'}}{T}
}
\end{gather*}

\caption{Bisimulation between \CBMachine\ and \SMachine{C}. It is the
  smallest congruence relation containing the shown rules. Everything
  to the left of $\approx$ is in \CBMachine{} and everything to the
  right is in \SMachine{C}.}
\label{fig:bisim-SC-D}
\end{figure}

% \begin{figure}

% \fbox{\bisimc{Z}{c}{S}{T}}
% \begin{gather*}
% \infr{}{\bisimc{[]}{id(T)}{T}{T}} \quad
% \infr{}{\bisimc{[\ccast{S}{l}{T}]}{\translate{\ccast{S}{l}{T}}}{S}{T}}
% \\[1ex]
% \infr{
% 	\bisimc{Z_1}{c_1}{T_1}{T_2}\\
% 	\bisimc{Z_2}{c_2}{T_2}{T_3}
% }{
% 	\bisimc{(Z_1 \mathrm{++} Z_2)}{(\compose{c_1}{c_2})}{T_1}{T_3}
% }
% \end{gather*}

% \fbox{$\bisimK{K}{K}{S}{T}$}
% \begin{gather*}
% \infr{
% 	\bisimK{K}{k'}{S_n}{T} \qquad
% 	\bisimc{Z}{c}{S_1}{S_n}
% }{
% 	\bisimK{
% 		\Kcons{\Fcast{Z}}{K}
% 	}{
% 		\Kcons{\Fcast{c'}}{k'}
% 	}{S_1}{T}
% }
% \end{gather*}

% \fbox{$\bisimv{v}{v}{T}$}
% \begin{gather*}
% \infr{
% 	\expressiontyping{\Gamma,x : S_1}{e}{T_1}
% 	\qquad
% 	\bisimE{\Gamma}{E}{E'}
% 	\\
% 	\bisimc{
% 		(\ccast{S_n}{\bar{l}_{n-1}}{S_{n-1}} \ldots
% 		\ccast{S_2}{\bar{l}_1}{S_1})
% 	}{c}{S_n}{S_1}
% 	\\
% 	\bisimc{
% 		(		\ccast{T_1}{l_{1}}{T_2} \ldots
% 		\ccast{T_{n-1}}{l_{n-1}}{T_n}
% 		)	}{d}{T_1}{T_n}
% 	\\
% 	v = \vfuncc{
% 		\vfuncc{
% 			\vfunc{x}{S_1}{e}{E}
% 		}{S_1}{T_1}{l_1}{S_2}{T_2}
% 		\ldots
% 	}{S_{n-1}}{T_{n-1}}{l_{n-1}}{S_n}{T_n}
% }{
% 	\bisimv{v}{
% 		(\ecast{\vfunc{x}{S_1}{e}{E'}}{\Pfunc{c}{d}})
% 	}{
% 		\Pfunc{S_n}{T_n}}
% }
% \\[1ex]
% \infr{
% 	\bisimv{v_1}{v_1'}{S_1} \qquad
% 	\bisimv{v_2}{v_2'}{T_1} \\
% 	\bisimc{
% 		(\ccast{S_1}{l_{1}}{S_2} \ldots
% 		\ccast{S_{n-1}}{l_{n-1}}{S_n})
% 	}{c}{S_1}{S_n} \\
% 	\bisimc{
% 		(\ccast{T_1}{l_{1}}{T_2} \ldots
% 		\ccast{T_{n-1}}{l_{n-1}}{T_n})
% 	}{d}{T_1}{T_n}
% 	\\ v = \vconsc{
% 		\vconsc{
% 			\vcons{v_1}{u_1}
% 		}{S_1}{T_1}{l_1}{S_2}{T_2}
% 		\ldots
% 	}{S_{n-1}}{T_{n-1}}{l_{n-1}}{S_n}{T_n}
% }{
% 	\bisimv{
% 		v
% 	}{
% 		(\ecast{\vcons{v_2}{u_2}}{\Pprod{c}{d}})
% 	}{
% 		\Pprod{S_n}{T_n}}
% }
% \end{gather*}
	
% \fbox{\bisimE{\Gamma}{E}{E}}
% \begin{gather*}
% \inference{
% }{
% 	\bisimE{\emptyset}{\emptyset}{\emptyset}
% }
% \quad
% \inference{
% 	\Gamma \vdash E \approx E' \qquad
% 	v \approx v' : T
% }{
% 	\Gamma , x : T \vdash 
% 	E [ x := v' ] \approx E' [ x := v' ]
% }
% \end{gather*}

% \fbox{\bisims{s}{s}{T}}
% \begin{gather*}
% \infr{}{\bisims{\error{l}}{\error{l}}{T}} \quad
% \infr{
% 	\bisimv{v}{v'}{T}
% }{
% 	\bisims{\shalt{v}}{\shalt{v'}}{T}
% }
% \\
% \infr{
% 	\bisimv{v}{v'}{S} \\
% 	\bisimK{K}{K'}{S}{T}
% }{
% 	\bisims{\scont{v}{K}}{\scont{v}{K'}}{T}
% } \quad
% \infr{
% 	\expressiontyping{\Gamma}{e}{S} \\
% 	\bisimE{\Gamma}{E}{E'}          \\
% 	\bisimK{K}{K'}{S}{T}
% }{
% 	\bisims{\sexpr{e}{E}{K}}{\sexpr{e}{E'}{K'}}{T}
% }
% \end{gather*}

% \caption{Bisimulation between \CBMachine\ and \SMachine{C}. It is the smallest 
% congruence relation containing the shown rules. Everything to the left (resp. 
% right) of $\approx$ is in \CBMachine\ (resp. in \SMachine{C}).}
% \label{fig:bisim-SC-D}
% \end{figure}


The central part of the proofs is a weak bisimulation between \CMachine{B} and \SMachine{C}.
Fig.~\ref{fig:bisim-SC-D} defines the bisimulation relation
between a state $s$ of \CMachine{B} and a state $s'$
of \SMachine{C}, written $\bisims{s}{s'}{T}$.
This relation is the smallest congruence relation containing the rules 
in Fig.~\ref{fig:bisim-SC-D}.

The auxiliary relation $\bisimc{\overline{\ccast{S}{l}{T}}}{c}{S}{T}$
relates a sequence of cast in \CBMachine\ with one cast in
\SMachine{C}. This relation is designed to cover all possibly ways to
construct a cast representation. The empty sequence is related to the
identity cast. A single \CBMachine\ cast is related to its
translation. Appending two sequences of casts is related to the
composition of the corresponding space-efficient casts.
%
We remark that this relation is unusual in that it uses some ADT
operations in its definition, such as $\id{T}$,
$\translate{\ccast{S}{l}{T}}$, and $\compose{c}{c}$, which is
necessary because \SMachine{C} and the bisimulation is parameterized
over the Cast ADT.

The bisimulation relation is mutually defined on
\begin{itemize}
\item continuations and pre-continuations, written $\bisimK{K}{K}{S}{T}$ and
  $\bisimK{K}{k}{S}{T}$, where $S$ and $T$ are their source and target
  types respectively,
\item values, written $\bisimv{v}{v}{T}$, where $T$ is
  their type, and
\item environments, written $\bisimE{\Gamma}{E}{E}$, where
  $\Gamma$ is their type environment.
\end{itemize}
The bisimulation relation for values is designed to make
Lemma~\ref{lem:LazyD-apply-cast-preserve-bisim} and
Lemma~\ref{lem:LazyUD-apply-cast-preserve-bisim} (described below)
true, that is, if $\bisimv{v}{v'}{S}$ then
\[
\bisimr{
	\applyCast{v}{\ccast{S}{l}{T}}
}{
	\denote{\translate{\ccast{S}{l}{T}}}(v')
}{T}
\]
So if two values of type $I$ are related, injecting them to $\Tdyn$
gives related values.
%
To relate function closures, the domain and codomain casts should be related. 
Closures in \CMachine{B} are proxied with a sequence of function casts, which 
can be viewed as two cast sequences in the obvious way.
%
The rule for products is similar.

One nice aspect of using abstract machines for this proof is that
the expressions in the machine are simply related by syntactic equality.

\begin{lemma}[Lazy D $\denote{c}(v)$ Preserves Bisimulation]
	\label{lem:LazyD-apply-cast-preserve-bisim}
	Assume $C$ is a Lazy D Cast ADT,
	$v$ is a value in \LDMachine,
	$v'$ is a value in \SMachine{C},
	and $\bisimv{v}{v'}{S}$
	\[
	\bisimr{
		\applyCast{v}{\ccast{S}{l}{T}}
	}{
		\denote{\translate{\ccast{S}{l}{T}}}(v')
	}{T}
	\]
\end{lemma}
\begin{proof}
  Proceed by cases on whether $S$ is shallowly consistent with $T$.
  If yes, proceed by cases regarding how they are shallowly consistent
  and then apply equations of Lazy D Cast.
\end{proof}

\begin{lemma}[Lazy UD $\denote{c}(v)$ Preserves Bisimulation]
	\label{lem:LazyUD-apply-cast-preserve-bisim}
	Assume $C$ implements Lazy UD Cast ADT,
	$v$ is a value in \LUDMachine,
	$v'$ is a value in \SMachine{C},
	and $\bisimv{v}{v'}{S}$
	\[
	\bisimr{
		\applyCast{v}{\ccast{S}{l}{T}}
	}{
		\denote{\translate{\ccast{S}{l}{T}}}(v')
	}{T}
	\]
\end{lemma}
\begin{proof}
  Proceed by cases on whether $S$ is shallowly consistent with $T$.
  If yes, further split on how they are shallowly consistent and then
  apply equations of Lazy UD Cast.
\end{proof}
%
%
%Before moving to the bisimulation proof, let's introduce two lemmas that 
%manipulate continuations.
%\begin{lemma}[$\mathit{mkCont}$ Preserves Bisimulation]
%	If \bisimK{K}{k}{S}{T} then
%	\[
%	\bisimK{K}{\mkCont{k}}{S}{T}.
%	\]
%\end{lemma}
%\begin{lemma}[$\mathit{extCont}$ Preserves Bisimulation]
%	If $\bisimc{
%		(\ccast{S_1}{l_1}{S_2}\ldots\ccast{S_{n-1}}{l_{n-1}}{S_n})
%	}{c}{S_1}{S_n}$
%	and $\bisimK{K}{K'}{S_n}{T}$ then
%	\[
%	\bisimK{
%		\Kcons{
%			\Fcast{\ccast{S_1}{l_1}{S_2}}
%		}{\ldots\Kcons{\Fcast{\ccast{S_{n-1}}{l_{n-1}}{S_n}}}{K}}
%	}{
%		\extCont{c}{K'}
%	}{S_1}{T}
%	\]
%\end{lemma}

We come to the main lemma, the weak bisimulation between
\CBMachine\ and \SMachine{C}.

\begin{lemma}[Weak Bisimulation between \CMachine{B} and \SMachine{C}] \label{lem:weak-bisimulation}
Assume
\begin{enumerate}
    \item the blame strategy $B$ and $C$ agrees on the set of injectable types and
    \item $\denote{c}(v)$ preserves the bisimulation relation (e.g. Lemma~\ref{lem:LazyD-apply-cast-preserve-bisim} and \ref{lem:LazyUD-apply-cast-preserve-bisim}) and
    \item $s_1$ is a state in \CMachine{B} and
    \item $s_1'$ is a state in \SMachine{C} and
    \item $\bisims{s_1}{s_1'}{T}$
\end{enumerate}	then either
\begin{enumerate}
\item $s_1  \text{ final}$ and $s_1' \text{ final}$ or
\item $\reduceto{s_1}{^{+}s_2}$
  and $\reduceto{s_1'}{^{+}s_2'}$
  and $\bisims{s_2}{s_2'}{T}$
\end{enumerate}
where the final predicate on states is defined as follows
\begin{gather*}
\infr{}{(\error{l})\text{ final}} \quad
\infr{}{(\shalt{v})\text{ final}}
\end{gather*}
\end{lemma}
\todo[inline]{KC: wouldn't it be great if I can describe the main ideas of the proof?}
\todo[inline]{JS: Yes, that would be great.}

% \begin{lemma}[Lazy D Weak Bisimulation between \LDMachine\ and \SMachine{C}]
% 	\label{lem:weak-bisim-SC-D}
% 	Assume $C$ implements Lazy D Cast ADT
% 	and $s_1$ is a state in \LDMachine\
% 	and $s_1'$ is a state in \SMachine{C}
% 	and $\bisims{s_1}{s_1'}{T}$
% 	then either
% \begin{enumerate}
% \item $s_1  = \error{l}$
%   and $s_1' = \error{l}$
%   for some $l$, or
% \item $s_1 = \shalt{v}$
%   and $s_1' = \shalt{v'}$
%   and $\bisimv{v}{v'}{T}$
%   for some $v$ and $v'$, or
% \item $\reduceto{s_1}{^{+}s_2}$
%   and $\reduceto{s_1'}{^{+}s_2'}$
%   and $\bisims{s_2}{s_2'}{T}$
% \end{enumerate}
% \end{lemma}
% %\begin{proof}
% %We proceed by case analysis on $\bisims{s_1}{s_1'}{T}$. 
% %\begin{description}
% %\item[Case $\inference{
% %}{
% %	\bisims{\error{l}}{\error{l}}{T}
% %}$]
% %This is case (1).
% %\item[Case $\inference{
% %	\bisimv{v}{v'}{T}
% %}{
% %	\bisims{\shalt{v}}{\shalt{v'}}{T}
% %}$]
% %This is case (2).
% %\item[Case $\inference{
% %	\expressiontyping{\Gamma}{e}{T} \\
% %	\bisimE{\Gamma}{E}{E'} \\
% %	K \approx K' : T
% %}{
% %	\bisims{\sexpr{e}{E}{K}}{\sexpr{e}{E'}{K'}}{T}
% %}$]
% %This is case (3). By case analysis on $e$.
% %\item[Case $\inference{
% %	\bisimv{v}{v'}{S} \\
% %	\bisimK{K}{K'}{S}{T}
% %}{
% %	\bisims{\scont{v}{K}}{\scont{v'}{K'}}{T}
% %}$]
% %This is case (3). By inversion on $\bisimK{K}{K'}{S}{T}$, we have
% %\[
% %\begin{array}{rcl}
% %K  & = &
% %\Kcons{
% %	\Fcast{\ccast{S_1}{l_1}{S_2}}
% %}{\ldots\Kcons{\Fcast{\ccast{S_{n-1}}{l_{n-1}}{S}}}{K_1}} \\
% %K' & = &
% %\Kcons{\Fcast{c'}}{k_1'}
% %\end{array}
% %\]
% %After zero or more transition steps, $\scont{v}{K}$ will either transition to 
% %$\scont{u}{K_1}$ for some $u$ or transition to $\error{l}$ for some $l$ if one 
% %of the cast fail. On the \SMachine{C} side, $\scont{v'}{K'}$ will either 
% %transition to $\applyCont{u'}{k_1'}$ for some $u'$ or transition to 
% %$\error{l'}$ for some $l'$ if the cast fail. Because the sequence of casts in 
% %$K$ bisimulates the cast in $K'$, we can show with  
% %Lemma~\ref{lem:LazyD-apply-cast-preserve-bisim} that either
% %\begin{itemize}
% %	\item all casts succeed and	$\bisimv{u}{u'}{S}$, or
% %	\item both machines transition to error state and $l = l'$
% %\end{itemize}
% %When all casts succeeded, we also have $\bisimK{K_1}{k_1'}{S}{T}$ and need to 
% %show that $\reduceto{\scont{u}{K_1}}{s_2}$ and $\applyCont{u'}{k_1'} = s_2'$ 
% %and $\bisims{s_2}{s_2'}{T}$ for some $s_2$ and $s_2'$.
% %%
% %We proceed by case analysis on $K$. The most interesting cases 
% %are function application and pair projection. Due to space limitation, 
% %we only illustrate the general idea with function applications
% %
% %\begin{description}
% %\item[Subcase $\infr{
% %	\bisimv{v_1}{v_1'}{\Pfunc{S}{T_1}} \qquad
% %	\bisimK{K_2}{K_2'}{T_1}{T}
% %}{
% %	\bisimK{
% %		\Kcons{\FappOX{v_1}}{K_2}
% %	}{
% %		\Kcons{\FappOX{v_1'}}{K_2'}
% %	}{S}{T}
% %}$] By inversion on $\bisimv{v_1}{v_1'}{\Pfunc{S}{T_1}}$ we know the proxies 
% %in $v_1$ bisimulate the proxies in $v_1'$. After a reasoning similar to the 
% %above one that we used to reason about casts in continuations, we know that 
% %either both machines will transition to error states if the input proxies fail 
% %in casting the argument, or both machines will transition to a state 
% %evaluation 
% %the function body.
% %\todo{need to elaborate this part, or just delete it.}
% %\end{description}
% %\end{description}
% %\end{proof}

% \begin{lemma}[Lazy UD Weak Bisimulation between \LUDMachine\ and \SMachine{C}]
% 	\label{lem:weak-bisim-SC-UD}
% 	Assume $C$ implements Lazy UD Cast ADT
% 	and $\bisims{s_1}{s_1'}{T}$
% 	then either
% 	\begin{enumerate}
% 		\item $s_1  = \error{l}$
% 		and $s_1' = \error{l}$
% 		for some $l$, or
% 		\item $s_1 = \shalt{v}$
% 		and $s_1' = \shalt{v'}$
% 		and $\bisimv{v}{v'}{T}$
% 		for some $v$ and $v'$, or
% 		\item $\reduceto{s_1}{^{+}s_2}$
% 		and $\reduceto{s_1'}{^{+}s_2'}$
% 		and $\bisims{s_2}{s_2'}{T}$
% 	\end{enumerate}
% \end{lemma}
% \begin{proof}
% 	Similar to Lemma~\ref{lem:weak-bisim-SC-D}.
% \end{proof}

\todo[inline]{There should be some text regarding the following
two theorems.}

\begin{theorem}[Correctness of Lazy D \SMachine{C}]
	\label{thm:SD-equiv}
	Suppose $C$ is a Lazy D Cast ADT
	\[
	\machineequiv{\CBMachine}{\SMachine{C}}
	\]
\end{theorem}
% \begin{proof}
% 	By the definitions of $\textit{eval}$, we need to show 
% 	\[
% 	\transitivelyreducetoM{\CMachine{B}}{\sexpr{e}{\emptyset}{\Knil}}{
% 		s
% 	}
% 	\;\text{if and only if}\;
% 	\transitivelyreducetoM{\SMachine{C}}{\sexpr{e}{\emptyset}{\mkCont{\Knil}}}{
% 		s'
% 	}
% 	\]
% 	where $s$ and $s'$ are bisimuated final states, i.e. of the form 
% 	$\shalt{v}$ or $\error{l}$. The initial states are related by the 
% 	bisimulation relation, so we can prove this theorem with 
% 	Lemma~\ref{lem:weak-bisim-SC-D}.
% \end{proof}

\begin{theorem}[Correctness of Lazy UD \SMachine{C}]
	\label{thm:SUD-equiv}
	Suppose $C$ is a Lazy UD Cast ADT
	\[
	\machineequiv{\CBMachine}{\SMachine{C}}
	\]
\end{theorem}
% \begin{proof}
% 	Similar to Theorem~\ref{thm:SD-equiv}.
% \end{proof}

\section{Hypercoercions, a New Cast Representation} \label{sec:hypercoercions}

In this section we present a new cast representation called hypercoercions. It 
comes with two flavors: Lazy D hypercoercions and Lazy UD one.  The design of 
hypercoercions is motivated by the observation that a normal coercion has at most three
parts. Hypercoercions make this structure explicit: a hypercoercion $c$ is
either \hcci, the identity cast for \Tdyn, or it contains
three parts: a head, middle, and tail, as defined in
\figref{fig:hypercoercion}.
\begin{itemize}
	\item a head is either a projection or the no-op;
	\item a middle $m$ involves coercions that preserve a type
	constructor, i.e., coercions between Boolean, function, and pair, and 
	failure coercions;
	\item a tail is either an injection or the no-op.
\end{itemize}

\begin{figure}[tp]
	Syntax of Hypercoercions
	\[
	\begin{array}{lrcl}
	\stxrule{c}{Hypercoercions}{
		\hcci           \mid
		\hccc{h}{m}{t}
	}
	\stxrule{h}{Heads}{
		\hche     \mid
		\hchp{I}{l}
	}
	\stxrule{m}{Middles}{
		\hcmbool       \mid
		\hcmfunc{c}{c} \mid
		\hcmprod{c}{c} \mid
		\hcmfail{l}    
	}
	\stxrule{t}{Tails}{
		\hcte     \mid
		\hcti{I}
	}
	\end{array}
	\]
	
	\fbox{$\mathit{id}( T ) = c$}
	\[
	\begin{array}{rclr}
	\figequalto{id(\star)}{
		\hcci
	}{}
	\figequalto{id(P)}{
		\hccc{\hche}{id(P)}{\hcte}
	}{}
	\end{array}
	\]
	
	\fbox{$\mathit{id}_m( P ) = m$}
	\[
	\begin{array}{rclr}
	\figequalto{id(\Pbool)}{\hcmbool}{}
	\figequalto{id(\Pfunc{S}{T})}{
		\hcmfunc{id(S)}{id(T)}
	}{}
	\figequalto{id(\Pprod{S}{T})}{
		\hcmprod{id(S)}{id(T)}
	}{}
	\end{array}
	\]
	
	\fbox{\casttyping{c}{S}{T}} Hypercoercion typing 
	\begin{gather*}
	\inference{}{\casttyping{\hcci}{\Tdyn}{\Tdyn}}
	\quad
	\inference{
		\casttyping{h}{S}{P} &
		\casttyping{m}{P}{Q} &
		\casttyping{t}{Q}{T}
	}{
		\casttyping{\hccc{h}{m}{t}}{S}{T}
	}
	\end{gather*}
	
	\fbox{\casttyping{h}{T}{P}} Head typing
	\begin{gather*}
	\inference{}{\casttyping{\hche}{P}{P}}
	\quad
	\inference{}{\casttyping{\hchp{I}{l}}{\Tdyn}{I}}
	\end{gather*}
	
	\fbox{$\casttyping{m}{T}{T}$} Middle typing
	\begin{gather*}
	\infr{}{\casttyping{\hcmfail{l}}{P}{Q}} \quad
	\inference{}{\casttyping{\hcmbool}{\Pbool}{\Pbool}} \\
	\inference{
		\casttyping{c}{S_2}{S_1} &
		\casttyping{d}{T_1}{T_2}
	}{
		\casttyping{\hcmfunc{c}{d}}{\Pfunc{S_1}{T_1}}{\Pfunc{S_2}{T_2}}
	}
	\quad
	\inference{
		\casttyping{c}{S_1}{S_2} &
		\casttyping{d}{T_1}{T_2}
	}{
		\casttyping{\hcmprod{c}{d}}{\Pprod{S_1}{T_1}}{\Pprod{S_2}{T_2}}
	}
	\end{gather*}
	
	\fbox{\casttyping{t}{P}{T}} Tail typing
	\begin{gather*}
	\inference{}{\casttyping{\hcte}{P}{P}} \quad
	\inference{}{\casttyping{\hcti{I}}{I}{\Tdyn}} \quad
	\end{gather*}
	
	\caption{Definition of hypercoercions}
	\label{fig:hypercoercion}
\end{figure}

Subsection~\ref{sec:LazyD-Hypercoercions} implements the \CastADT\ with the \LD\ 
hypercoercions and proves that \LD\ hypercoercions is a Lazy D Cast ADT. 
Subsection~\ref{sec:LazyUD-Hypercoercions} does the \LUD\ counterparts.
Finally, we argue in Subsection~\ref{sec:hypercoercions-compact} that 
hypercoercions would consume less space than coercions in 
normal form and hence are more suitable for implementation.

\subsection{\LD\ Hypercoercions}
\label{sec:LazyD-Hypercoercions}

\begin{figure}[tp] %% composition 1
\[
\begin{array}{lrcl}
\stxrule{g}{Gaps}{
	\gnone           \mid
	\gsome{S}{l}{T}
}
\end{array}
\]


\fbox{$\compose{c}{c} = c$} Composition of \LD\ hypercoercions
\[
\begin{array}{rclr}
\figequalto{\compose{c_1}{c_2}}{\composegap{c_1}{\gnone}{c_2}}{}
\end{array}
\]

\fbox{$\composegap{c}{g}{c} = c$}
\[
\begin{array}{rcll}
\figequalto{\composegap{\hcci}{g}{\hcci}}{\hcci}{}
\figequalto{\composegap{\hcci}{g}{\hccc{h}{m}{t}}}{
	\hccc{\mkhead{g}{h}}{m}{t}
}{}
\figequalto{\composegap{\hccc{h}{m}{t}}{g}{\hcci}}{
	\hccc{h}{m}{\mktail{t}{g}}
}{}
\figequalto{\composegap{\hccc{h_1}{m_1}{t_1}}{g}{\hccc{h_2}{m_2}{t_2}}}{
	\hccc{h_1}{(\composegap{m_1}{\mkgap{t_1}{g}{h_2}}{m_2})}{t_2}
}{}
\end{array}
\]

\fbox{\mkhead{g}{h}}
\[
\begin{array}{rclr}
\figequalto{\mkhead{g}{\hchp{P}{l}}}{\hchp{P}{l}}{}
\figequalto{\mkhead{\gsome{\Tdyn}{l}{P}}{\hche}}{\hchp{P}{l}}{}
%\mathit{mkProj(}
%& g
%& ,
%& \hchp{P}{l}
%& )=
%& \hchp{P}{l} \\
%\mathit{mkProj(}
%& \gsome{\Tdyn}{l}{P}
%& ,
%& \hche
%& )=
%& \hchp{P}{l}
\end{array}
\]
%\[
%\begin{array}{rcll}
%\figequalto{\mkhead{g}{\hchp{P}{l}}}{\hchp{P}{l}}{}
%\figequalto{\mkhead{\gsome{\Tdyn}{l}{P}}{\hche}}{\hchp{P}{l}}{}
%\end{array}
%\]

\fbox{\mktail{t}{g}}
\[
\begin{array}{rcll}
\figequalto{\mktail{\hcti{P}}{g}}{\hcti{P}}{}
\figequalto{\mktail{\hcte}{\gsome{P}{l}{\Tdyn}}}{\hcti{P}}{}
\end{array}
\]

\fbox{\mkgap{t}{g}{h}}
\[
\begin{array}{rcll}
\figequalto{\mkgap{\hcte}{g}{\hche}}{g}{}
\figequalto{\mkgap{\hcte}{\gsome{P}{l'}{\Tdyn}}{\hchp{Q}{l}}}{
	\gsome{P}{l}{Q}
}{}
\figequalto{\mkgap{\hcti{P}}{g}{\hchp{Q}{l}}}{
	\gsome{P}{l}{Q}
}{}
\figequalto{\mkgap{\hcti{P}}{\gsome{\Tdyn}{l}{Q}}{\hche}}{
	\gsome{P}{l}{Q}
}{}
\end{array}
\]

\fbox{$\composegap{m}{g}{m} = m$}
\[ 
\begin{array}{rclr}
\figequalto{\composegap{\hcmfail{l}}{g}{m_2}}{
	\hcmfail{l}
}{}
\figequalto{\composegap{m_1}{\gsome{P}{l}{Q}}{m_2}}{
	\hcmfail{l}
}{\\&&\sidecond{
		\notshallowlyconsistent{P}{Q}
		\text{ and } \forall l. m_1 \neq \hcmfail{l}
}}
\figequalto{\composegap{m_1}{g}{\hcmfail{l}}}{
	\hcmfail{l}
}{\\&&\sidecond{
		\goodgap{g}
		\text{ and } \forall l. m_1 \neq \hcmfail{l}}}
\figequalto{\composegap{\hcmbool}{g}{\hcmbool}}{
	\hcmbool
}{}
\figequalto{
	\composegap{
		(\hcmfunc{c_1}{d_1})}{
		g}{
		(\hcmfunc{c_2}{d_2})}
}{
	\hcmfunc{
		(\composegap{c_2}{\dom{g}}{c_1})}{
		(\composegap{d_1}{\cod{g}}{d_2})}
}{}
\figequalto{
	\composegap{
		(\hcmprod{c_1}{d_1})}{
		g}{
		(\hcmprod{c_2}{d_2})}
}{
	\hcmprod{
		(\composegap{c_1}{\fst{g}}{c_2})}{
		(\composegap{d_1}{\snd{g}}{d_2})}
}{}
\end{array}
\]	

\fbox{$\goodgap{g}$}
\begin{gather*}
\infr{}{\goodgap{\gnone}} \quad
\infr{\shallowlyconsistent{P}{Q}}{\goodgap{\gsome{P}{l}{Q}}}
\end{gather*}

\fbox{$\dom{g}=g$}
\[
\begin{array}{rclr}
\figequalto{\dom{\gnone}}{\gnone}{}
\figequalto{\dom{\gsome{\Pfunc{S_1}{T_1}}{l}{\Pfunc{S_2}{T_2}}}}{
	\gsome{S_2}{l}{S_1}
}{}
\end{array}
\]

\fbox{$\cod{g}=g$}
\[
\begin{array}{rclr}
\figequalto{\cod{\gnone}}{\gnone}{}
\figequalto{\cod{\gsome{\Pfunc{S_1}{T_1}}{l}{\Pfunc{S_2}{T_2}}}}{
	\gsome{T_1}{l}{T_2}
}{}
\end{array}
\]

\fbox{$\fst{g}=g$}
\[
\begin{array}{rclr}
\figequalto{\fst{\gnone}}{\gnone}{}
\figequalto{\fst{\gsome{\Pprod{S_1}{T_1}}{l}{\Pprod{S_2}{T_2}}}}{
	\gsome{S_1}{l}{S_2}
}{}
\end{array}
\]

\fbox{$\snd{g}=g$}
\[
\begin{array}{rclr}
\figequalto{\snd{\gnone}}{\gnone}{}
\figequalto{\snd{\gsome{\Pprod{S_1}{T_1}}{l}{\Pprod{S_2}{T_2}}}}{
	\gsome{T_1}{l}{T_2}
}{}
\end{array}
\]

	\caption{Composition of \LD\ Hypercoercions}
	\label{fig:LazyD-Hypercoercions-composition}
\end{figure}


\figref{fig:LazyD-Hypercoercions-composition} defines the functions 
\compose{c}{c} that compose \LD\ hypercoercions. We use these functions to 
implement the \CastADT.

\todo[inline]{KC: (About the following paragraph) Should we mention KC and Deyaa as citation?
(something like in private communication with KC and Deyaa)}

The \compose{c}{c} operator is the key to compressing coercions and maintaining 
space-efficiency. The composition operator for Coercions in Normal Form 
requires the target type of the first coercion to match the source type of the 
second. This requirement, however, imposes a considerable difficulty in 
termination proof of the composition of \LD\ Coercions in Normal Form, reported 
by Kuang-Chen Lu and Deyaaeldeen Almahallawi. So it is useful to relax this 
restriction for the \LD\ tracking strategy.
%
We shall need optional source cast, written $g$, that range over
$\gnone$ or $\gsome{S}{l}{T}$, to maintain the gap between the hypercoercions 
to be composed. The source cast is mandatory when the target
type of the first hypercoercion does not match the source type of the second. 
Then we write the composition of hypercoercions as \composegap{c_1}{g}{c_2}.
%  
When both $c_1$ and $c_2$ are \hcci, their composition is also \hcci. 
%
When the first hypercoercion is the \hcci, the output must start with a 
projection, in which case we invoke the helper function \textit{mkProj}. In 
\textit{mkProj}, if the head of $c_2$ is a projection, the result is $c_2$.  
Otherwise, we need a label to build the projection. Since the head of $c_2$ is 
the no-op, its source type must be a pretype. Thus we know $g$ must be a 
source cast and we use it to construct the projection.
%
Going back to $\composegap{c}{g}{c}$, when the second hypercoercion is the 
\hcci, the output must end with an injection, in which case we invoke the 
helper function \textit{mkInj}.
%
Finally, when both inputs are of the form \hccc{h}{m}{t}, we compose the middle 
with an updated gap.
%
The second and third cases of \mkgap{t}{g}{h} is interesting, where we choose 
the label in projection to be responsible for potential inconsistency.

Another interesting operator is the middle composition \composegap{m}{g}{m}. 
%
When the first middle is a failure (\hcmfail{l}), the result is the second
middle. In all the remaining cases, the first middle is not a failure.
%
When the gap is a cast between shallowly inconsistent types (i.e. having 
different top-most constructors). the output is a failure.
%
When the gap is good but the second middle is a failure, the output is the same 
failure. A gap $g$ is good if and only if there is not $P$ and $l$ 
and $Q$ such that $g = \gsome{P}{l}{Q}$ and \notshallowlyconsistent{P}{Q}.
%
The remaining cases are straightforward recursion.

Agda is able to understand that \composegap{c}{g}{c} is terminating. The reason 
might be that in \composegap{c}{g}{c} both casts become smaller in recursive 
calls, although their position is swapped in the function case. Readers who
hate non-structural recursion might add a Boolean parameter to indicate the order
of composition.

\begin{figure}[tp]
	\fbox{$\translate{\ccast{S}{l}{T}} = c$} Translation of \LD\ hypercoercions
	\[
	\begin{array}{rclr}
	\figequalto{\translate{\ccast{S}{l}{T}}}{\composegap{id(S)}{(\gsome{S}{l}{T})}{id(T)}}{}
	\end{array}
	\]
	\caption{Translatin of \LD\ Hypercoercions}
	\label{fig:LazyD-Hypercoercions-translation}
\end{figure}

The definition of translation \translate{\ccast{S}{l}{T}} is straightforward 
(\figref{fig:LazyD-Hypercoercions-translation}).

\begin{figure}[tp]
\fbox{$\denote{c}(v)=r$}
\[
\begin{array}{rclr}
\figequalto{\denote{\hcci}(v)}{v}{}
\figequalto{\denote{\hccc{h}{m}{t}}(v)}{
	(\denote{h}_h(v) \mbind \denote{m}_m)
	\mbind \denote{t}_t
}{}
\end{array}
\]

\fbox{$\denote{h}_h(v)=r$}
\[
\begin{array}{rclr}
\figequalto{\denote{\hche}(v)}{v}{}
\figequalto{\denote{\hchp{Q}{l}}(\vdyn{P}{u})}{
	\denote{\composegap{\idm{P}}{\gsome{P}{l}{Q}}{\idm{Q}}}_m(u)
}{}
\end{array}
\]

\fbox{$\denote{m}_m(v)=r$}
\[
\begin{array}{rclr}
\figequalto{\denote{\hcmfail{l}}(v)}{\error{l}}{}
\figequalto{\denote{\hcmbool}(v)}{v}{}
\figequalto{\denote{\hcmfunc{d_1}{d_2}}(\ecast{\vfunc{x}{S}{e}{E}}{\Pfunc{c_1}{c_2}})}{
	\ecast{\vfunc{x}{S}{e}{E}}{\Pfunc{(\compose{d_1}{c_1})}{(\compose{c_2}{d_2})}}
}{}
\figequalto{\denote{\hcmprod{d_1}{d_2}}(\ecast{\vcons{v_1}{v_2}}{\Pprod{c_1}{c_2}})}{
	\ecast{\vcons{v_1}{v_2}}{\Pprod{(\compose{c_1}{d_1})}{(\compose{c_2}{d_2})}}
}{}
\end{array}
\]

\fbox{$\denote{t}_t(v)=r$}
\[
\begin{array}{rclr}
\figequalto{\denote{\hcte}(v)}{v}{}
\figequalto{\denote{\hcti{P}}(v)}{\vdyn{P}{v}}{}
\end{array}
\]
\caption{Application of \LD\ Hypercoercions}
\label{fig:LazyD-Hypercoercions-application}
\end{figure}

Fig.~\ref{fig:LazyD-Hypercoercions-application} defines the cast application 
function for \LD\ hypercoercions.
Applying the identity cast for the dynamic type succeeds immediately. 
Otherwise, we apply head, middle, and tail in sequence. 
%
In projection case of head application, a new middle is constructed and applied 
to the injected value.
%
Middle applications raises an error if the middle is a failure and extend value 
proxies otherwise.

\begin{proposition} Lazy D Hypercoercions implement the Lazy D Cast ADT
\end{proposition}
\begin{theorem}[Lazy D Hypercoercions are Correct] Let $H$ be the Lazy D 
hypercoercions,
\[\machineequiv{\LDMachine}{\SMachine{H}}\]
\end{theorem}


\subsection{\LUD\ Hypercoercions} \label{sec:LazyUD-Hypercoercions}

Hypercoercions for the \LUD\ blame tracking strategy have the same syntax
as for \LD\ (\figref{fig:hypercoercion}), but the definitions of $\id{T}$ and
$\translate{\ccast{S}{l}{T}}$ and $\compose{c}{c}$, differ from \LD. Here 
composition $\compose{c_1}{c_2}$ makes the usual assumption that the
target type of $c_1$ matches the source type of $c_2$. 
%
The definition of composition for \LUD\ is particularly straightforward.
The first two lines say that \hcci\ acts as the identity on both the left
and right.
The third line handles the case when both hypercoercions have three parts. 
%
The first three lines of the middle composition $m \fatsemi t \fatsemi h 
\fatsemi m$ function match its arguments in sequential order to determine which 
label to blame. The forth and last line is straightforward recursion.

\todo[inline]{KC: I need a better name for \compatibletailhead{t}{h}}

%The third line handles the case when both the tail of $c_1$
%and the head of $c_2$ are no-ops, in which case the middles types
%$m_1$ and $m_2$ are composed via an auxiliary composition
%operator. This compose operator for middle coercions assumes that its
%inputs are shallowly consistent.  The fourth line handles the
%important case when the tail of $c_1$ is an injection and the head of
%$c_2$ is a projection. If the two middle coercions are shallowly
%consistent, then they can be composed. If not, the tail of the result
%is a failure coercion with the projection's label.  The last line
%handles the case when the tail of $c_1$ is a failure, in which case
%the result of composition is $c_1$. The definition of $id$ is straightforward.

\begin{figure}[tp]
	\fbox{$c \fatsemi c = c$}
	\[
	\begin{array}{rclcl}
		\hcci          
		& \fatsemi & d
		& = & d \\
		\hccc{h}{m}{t}
		& \fatsemi & \hcci
		& = & \hccc{h}{m}{t} \\
		\hccc{h_1}{m_1}{t_1}
		& \fatsemi & \hccc{h_2}{m_2}{t_2}
		& = & \hccc{h_1}{(m_1 \fatsemi t_1 \fatsemi h_2 \fatsemi m_2)}{t_2}
	\end{array}
	\]

	\fbox{$m \fatsemi t \fatsemi h \fatsemi m = m$}
	\[
	\begin{array}{rccccclclr}
	\hcmfail{l} 
	& \fatsemi & t
	& \fatsemi & h
	& \fatsemi & m_2
	& = & \hcmfail{l} \\
	m_1
	& \fatsemi & \hcti{G}
	& \fatsemi & \hchp{H}{l}
	& \fatsemi & m_2
	& = & \hcmfail{l}
	& \sidecond{G \neq H \text{ and } \forall l. m_1 \neq \hcmfail{l}} \\
	m_1
	& \fatsemi & t
	& \fatsemi & h
	& \fatsemi & \hcmfail{l}
	& = & \hcmfail{l}
	& \sidecond{\compatibletailhead{t}{h}
		\text{ and } \forall l. m_1 \neq \hcmfail{l}} \\
	m_1
	& \fatsemi & t
	& \fatsemi & h
	& \fatsemi & m_2
	& = & m_1 \fatsemi m_2
	& \sidecond{
		\forall l. m_2 \neq \hcmfail{l}
		\text{ and } \compatibletailhead{t}{h}
		\text{ and } \forall l. m_1 \neq \hcmfail{l}} \\
	\end{array}
	\]
	
	\fbox{$m \fatsemi m = m$}
	\[
	\begin{array}{rclcl}
	\hcmbool
	& \fatsemi & \hcmbool
	& = & \hcmbool \\
	\hcmfunc{c_1}{d_1}
	& \fatsemi & \hcmfunc{c_2}{d_2}
	& = & \hcmfunc{c_2 \fatsemi c_1}{d_1 \fatsemi d_2} \\
	\hcmprod{c_1}{d_1}
	& \fatsemi & \hcmprod{c_2}{d_2}
	& = & \hcmprod{c_2 \fatsemi c_1}{d_1 \fatsemi d_2} \\
	\end{array}
	\]
	
	\fbox{\compatibletailhead{t}{h}}
	\begin{gather*}
	\infr{}{\compatibletailhead{\hcte}{\hche}}
	\quad
	\infr{}{\compatibletailhead{\hcti{G}}{\hchp{G}{l}}}
	\end{gather*}
	
\caption{\LUD\ Hypercoercions (1): composition}
\label{fig:LazyUD-Hypercoercions-composition}
\end{figure}

\begin{figure}[tp]
	\fbox{$\translate{\ccast{S}{l}{T}} = c$}
	\[
	\begin{array}{rcll}
	\figequalto{\translate{\ccast{\Tdyn}{l}{\Tdyn}}}{\hcci}{}
	\figequalto{\translate{\ccast{\Tdyn}{l}{Q}}}{\castFromDyn{l}{Q}}{}
	\figequalto{\translate{\ccast{P}{l}{\Tdyn}}}{\castToDyn{P}{l}}{}
	\figequalto{\translate{\ccast{P}{l}{Q}}}{
		\hccc{\hche}{\hcmfail{l}}{\hcte}
	}{\sidecond{\notshallowlyconsistent{P}{Q}}}
	\figequalto{\translate{\ccast{\Pbool}{l}{\Pbool}}}{
		\hccc{\hche}{\hcmbool}{\hcte}
	}{}
	\figequalto{\translate{\ccast{\Pfunc{S_1}{T_1}}{l}{\Pfunc{S_2}{T_2}}}}{
		\hccc{\hche}{
			\hcmfunc{
				\translate{\ccast{S_2}{l}{S_1}}}{
				\translate{\ccast{T_1}{l}{T_2}}}
		}{\hcte}
	}{}
	\figequalto{\translate{\ccast{\Pprod{S_1}{T_1}}{l}{\Pprod{S_2}{T_2}}}}{
		\hccc{\hche}{
			\hcmprod{
				\translate{\ccast{S_1}{l}{S_2}}}{
				\translate{\ccast{T_1}{l}{T_2}}}
		}{\hcte}
	}{}
	\end{array}
	\]
	
	\fbox{$\castFromDyn{Q}{l}$}
	\[
	\begin{array}{rcll}
\figequalto{\castFromDyn{\Tdyn}{l}}{\hcci}{}
\figequalto{\castFromDyn{\Pbool}{l}}{
	\hccc{\hchp{\Gbool}{l}}{
		\hcmbool
	}{\hcte}
}{}
\figequalto{\castFromDyn{\Pfunc{S}{T}}{l}}{
	\hccc{\hchp{\Gfunc}{l}}{
		\hcmfunc{\castToDyn{S}{l}}{\castFromDyn{T}{l}}
	}{\hcte}
}{}
\figequalto{\castFromDyn{\Pprod{S}{T}}{l}}{
	\hccc{\hchp{\Gprod}{l}}{
		\hcmprod{\castFromDyn{S}{l}}{\castFromDyn{T}{l}}
	}{\hcte}
}{}
	\end{array}
	\]
	
	\fbox{$\castToDyn{Q}{l}$}
	\[
	\begin{array}{rcll}
\figequalto{\castToDyn{\Tdyn}{l}}{\hcci}{}
\figequalto{\castToDyn{\Pbool}{l}}{
	\hccc{\hche}{
		\hcmbool
	}{\hcti{\Gbool}}
}{}
\figequalto{\castToDyn{\Pfunc{S}{T}}{l}}{
	\hccc{\hche}{
		\hcmfunc{\castFromDyn{S}{l}}{\castToDyn{T}{l}}
	}{\hcti{\Gfunc}}
}{}
\figequalto{\castToDyn{\Pprod{S}{T}}{l}}{
	\hccc{\hche}{
		\hcmprod{\castToDyn{S}{l}}{\castToDyn{T}{l}}
	}{\hcti{\Gprod}}
}{}
	\end{array}
	\]
\caption{\LUD\ Hypercoercions (2): translation}
\label{fig:LazyUD-Hypercoercions-translation}
\end{figure}

The translation function \translate{\ccast{S}{l}{T}} is defined in 
\figref{fig:LazyUD-Hypercoercions-translation}.  Prior
presentations of this function do not use auxiliary functions, as we
do here. The reason that we introduce the auxiliary functions
$\mathit{castToDyn}$ and $\mathit{castFromDyn}$, is to ensure that each of them 
is structurally recursive, which makes them straightforward to define in
Agda.

\begin{figure}[tp]
	\fbox{$\denote{c}_c(v)=r$}
	\[
	\begin{array}{rclr}
	\figequalto{\denote{\hcci}(v)}{v}{}
	\figequalto{\denote{\hccc{h}{m}{t}}(v)}{
		(\denote{h}(v) \mbind \denote{m})
		\mbind \denote{t}
	}{}
	\end{array}
	\]
	
	\fbox{$\denote{h}_h(v)=r$}
	\[
	\begin{array}{rclr}
	\figequalto{\denote{\hche}(v)}{v}{}
	\figequalto{\denote{\hchp{G}{l}}(\vdyn{G}{u})}{u}{}
	\figequalto{\denote{\hchp{H}{l}}(\vdyn{G}{u})}{\error{l}}{
		\sidecond{G \neq H}
	}
	\end{array}
	\]
	
	\fbox{$\denote{m}_m(v)=r$}
	\[
	\begin{array}{rclr}
	\figequalto{\denote{\hcmfail{l}}(v)}{\error{l}}{}
	\figequalto{\denote{\hcmbool}(v)}{v}{}
	\figequalto{\denote{\hcmfunc{d_1}{d_2}}(\ecast{\vfunc{x}{S}{e}{E}}{\Pfunc{c_1}{c_2}})}{
		\ecast{\vfunc{x}{S}{e}{E}}{\Pfunc{(\compose{d_1}{c_1})}{(\compose{c_2}{d_2})}}
	}{}
	\figequalto{\denote{\hcmprod{d_1}{d_2}}(\ecast{\vcons{v_1}{v_2}}{\Pprod{c_1}{c_2}})}{
		\ecast{\vcons{v_1}{v_2}}{\Pprod{(\compose{c_1}{d_1})}{(\compose{c_2}{d_2})}}
	}{}
	\end{array}
	\]
	
	\fbox{$\denote{t}_t(v)=r$}
	\[
	\begin{array}{rclr}
	\figequalto{\denote{\hcte}(v)}{v}{}
	\figequalto{\denote{\hcti{G}}(v)}{\vdyn{G}{v}}{}
	\end{array}
	\]
	\caption{Application of \LUD\ Hypercoercions}
	\label{fig:LazyUD-Hypercoercions-application}
\end{figure}

Fig.~\ref{fig:LazyUD-Hypercoercions-application} defines the cast application 
function for \LUD\ hypercoercions.
Applying the identity cast for the dynamic type succeeds immediately. 
Otherwise, we apply head, middle, and tail in sequence. 
%
In the two projection cases of head application, the result depends on whether 
the source ground type ($G$) is the same as the target ($H$).
%
Middle applications raises an error if the middle is a failure and extend value 
proxies otherwise.

\begin{proposition} Lazy UD Hypercoercions implement the Lazy UD Cast ADT
\end{proposition}
\begin{theorem}[Lazy UD Hypercoercions are Correct] Let $H$ be the Lazy UD 
	hypercoercions,
	\[\machineequiv{\LDMachine}{\SMachine{H}}\]
\end{theorem}

\subsection{Compact Representation of Hypercoercions} \label{sec:hypercoercions-compact}

Hypercoercions enable a bit-level representation that is particularly
compact for identity coercions and coercions that project from base
types or inject to base types.  (Here \Pbool\ is the only base
type, but in a real language the base types would include integers,
Booleans, etc.)  We conjecture that such coercions occur more
frequently than the more complex coercions (e.g. between function
types), especially because such coercions appear in the leaves of
complex coercions.

Furthermore, values of base types are often stored in CPU registers, so
it would be nice for coercions on base types to also fit in registers,
that is, in 64 bits, so that applying a coercion to a value of base
type would not require access to main memory, which is an order of
magnitude slower than accessing registers on a modern CPU.
%
Coercions involving non-base types, such as function types, may be
arbitrarily deep, so in those cases, the hypercoercion representation
has to be a pointer to a heap-allocated structure.

Here is a sketch for the bit-level representation for hypercoercions.

\begin{itemize}
\item 1 bit to differentiate between \hcci\ and three-part coercions.

\item 1 bit to differentiate between middle coercions of base type
versus non-base type.

\item If the middle is a non-base type or bottom ($\hcmfail{l}$), then 61 bits 
represent a
pointer to a heap-allocated structure. Heap allocated structures are
usually 8-byte aligned, so there are 3 unused bits in a pointer.

\item If the middle is of base types, then the remaining 62 bits are
used to represent the head (51 bits), middle (10 bit), and tail (1
bit).
\begin{itemize}
\item The head requires 1 bit to differentiate between $\hche$
and $\hchp{P}{l}$ and then 50 bits could be used for the label $l$.
\item The middle would use 10 bits to differentiate all the base types.
\item The tail requires 1 bits to differentiate between $\hcte$ and $\hcti{P}$, 
where $P$ must be equal to the middle type.
\end{itemize}
The bits for blame labels represent an index into a table of blame information.
In the event that a program requires too many blame labels, then the 
implementation
can fallback to using the heap-allocated structure for more
coercions.
\end{itemize}

\section{Conclusion} \label{sec:conclusion}

We present steps toward the first framework for proving the
correctness of cast representations.
%
The framework includes abstract data types for cast representations
(Cast ADT and its refinements Lazy D Cast ADT and \LUD\ \CastADT), 
a parameterized abstract machine \SMachine{C}, 
a theorem which states that \SMachine{C} is equivalent
to \LDMachine\ when $C$ is a Lazy D Cast ADT, and
a theorem which states that \SMachine{C} is equivalent
to \LUDMachine\ when $C$ is a Lazy UD Cast ADT.
%
%The Lazy D Cast ADT refines the Cast ADT. 
%
We applied this framework to Lazy UD coercions in normal form,
Lazy UD threesomes, and hypercoercions and conjecture that
this framework is also applicable to other cast representations.

We also presented hypercoercions, a cast representation that has a 
theorem-prover-friendly compose operator and a more compact memory
representation in comparison with coercions in normal forms.

%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
% \bibliographystyle{splncs04}
% \bibliography{mybibliography}
%
%\bibliographystyle{splncs04}
\bibliographystyle{splncsnat}
\bibliography{bibfile,all-modified}{}

\end{document}
